{
  "Authenticate.js": "exports.Auth = (function() {\n\n\t//-----------------------------------------------------dispatch\n\tvar dispatch = {\n\t\tLogin: Login\n\t};\n\n\treturn {\n\t\tdispatch: dispatch\n\t};\n\n\tfunction authenticate(authData, fun) {\n\t\tif (!authData.Username && !authData.Password) {\n\t\t\tfun('No Username or Password', null);\n\t\t\treturn;\n\t\t}\n\n\t\t__Fs3.readFile(__Config.Users + authData.Username + '.json', function(err, data) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t\tfun('Invalid Username', null);\n\t\t\t} else {\n\t\t\t\tlet userData = JSON.parse(data);\n\t\t\t\tconsole.log('UserData:', userData);\n\t\t\t\tconsole.log('AuthData:', authData);\n\t\t\t\tif (authData.Password == userData.Password) {\n\t\t\t\t\tlet q = {};\n\t\t\t\t\tq.UserPid = userData.Pid;\n\t\t\t\t\tq.Username = authData.Username;\n\t\t\t\t\tq.Password = authData.Password;\n\t\t\t\t\tfun(null, q);\n\t\t\t\t} else {\n\t\t\t\t\tfun('Invalid Password', null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}\n})();\n",
  "Http.js": "//# sourceURL=server/http\n(function Http() {\n\tlet async, jszip;\n\n\t//-----------------------------------------------------dispatch\n\tvar dispatch = {\n\t\tSetup: Setup,\n\t\tStart: Start,\n\t\tGetModule: GetModule,\n\t\t'*': Publish\n\t};\n\n\treturn {\n\t\tdispatch: dispatch\n\t};\n\n\tfunction Setup(com, fun) {\n\t\tlog.v('--Http/Setup');\n\n\t\tasync = this.require('async');\n\t\tjszip = this.require(\"jszip\");\n\n\t\tif (fun)\n\t\t\tfun();\n\t}\n\n\tfunction Start(com, fun) {\n\t\tlog.v('--Http/Start');\n\t\tvar that = this;\n\t\tvar http = this.require('http');\n\t\tvar sockio = this.require('socket.io');\n\t\tvar port;\n\t\tvar Par = this.Par;\n\t\tvar Vlt = this.Vlt;\n\t\tVlt.Session = this.genPid();\n\t\tif ('Port' in this.Par)\n\t\t\tport = this.Par.Port;\n\t\telse\n\t\t\tport = 8080;\n\t\tvar web = http.createServer(function (req, res) {\n\t\t\t//\tconsole.log(req.method + ':' + req.url);\n\t\t\tswitch (req.method) {\n\t\t\t\tcase 'POST':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'GET':\n\t\t\t\t\tGet(that, req, res);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\tweb.listen(port);\n\t\twebSocket(web);\n\t\tconsole.log(' ** Spider listening on port', port);\n\t\tif ('Config' in this.Par) {\n\t\t\treadBrowser(null, this.Par.Config);\n\t\t} else {\n\t\t\treadBrowser('Config not in Par', null);\n\t\t}\n\n\t\tfunction readBrowser(err, data) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** ERR::Cannot read browser config');\n\t\t\t\tfun(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVlt.Browser = JSON.parse(data.toString());\n\t\t\tgetscripts();\n\t\t}\n\n\t\tfunction getscripts() {\n\t\t\tthat.getFile('scripts.json', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(' ** ERR:Cannot read script.json');\n\t\t\t\t\tfun(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tVlt.Browser.Scripts = JSON.parse(data.toString());\n\t\t\t\tgetnxs();\n\t\t\t})\n\t\t}\n\n\t\tfunction getnxs() {\n\n\t\t\tthat.getFile('Nxs.js', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(' ** ERR:Cannot read Nxs file');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tVlt.Browser.Nxs = data.toString();\n\t\t\t\tfun();\n\t\t\t});\n\t\t}\n\n\t\t//---------------------------------------------------------webSocket\n\t\tfunction webSocket(web) {\n\t\t\tvar listener = sockio.listen(web);\n\t\t\tVlt.Sockets = {};\n\t\t\tvar Sockets = Vlt.Sockets;\n\n\t\t\tlistener.sockets.on('connection', function (socket) {\n\t\t\t\t// console.log('sock/connection');\n\t\t\t\tvar pidsock = '';\n\t\t\t\tfor (var i = 0; i < 3; i++)\n\t\t\t\t\tpidsock += that.genPid().substr(24);\n\t\t\t\tvar obj = {};\n\t\t\t\tobj.Socket = socket;\n\t\t\t\tobj.User = {};\n\t\t\t\tobj.User.Pid = '160D25754C01438388CE6A946CD4480C';\n\t\t\t\tSockets[pidsock] = obj;\n\n\t\t\t\tvar cfg = Vlt.Browser;\n\t\t\t\tcfg.Pid24 = pidsock;\n\t\t\t\tcfg.PidServer = Par.Pid;\n\t\t\t\tcfg.ApexList = Par.ApexList || {};\n\t\t\t\tvar str = JSON.stringify(cfg);\n\t\t\t\tsocket.send(str);\n\n\t\t\t\tsocket.on('disconnect', function () {\n\t\t\t\t\t// console.log(' >> Socket', pidsock, 'disconnected');\n\t\t\t\t\tdelete Sockets[pidsock];\n\t\t\t\t});\n\n\t\t\t\tsocket.on('error', function (err) {\n\t\t\t\t\t// console.log(' >> Socket', pidsock, '**ERR:' + err);\n\t\t\t\t\tdelete Sockets[pidsock];\n\t\t\t\t});\n\n\t\t\t\tsocket.on('message', function (msg) {\n\t\t\t\t\t//debugger;\n\t\t\t\t\tvar com = JSON.parse(msg);\n\t\t\t\t\t//console.log('>>Msg:' + JSON.stringify(com));\n\t\t\t\t\tif (!com) {\n\t\t\t\t\t\tconsole.log(' ** onMessage: Invalid message');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (com.Cmd == 'GetFile') {\n\t\t\t\t\t\tgetfile();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (com.Cmd == 'Subscribe') {\n\t\t\t\t\t\tobj.User.Publish = com.Pid;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!('Passport' in com)) {\n\t\t\t\t\t\tconsole.log(' ** ERR:No Passport in routed msg');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// debugger;\n\t\t\t\t\t//\tcom.Passport.User = obj.User;\n\t\t\t\t\tif ('Reply' in com.Passport && com.Passport.Reply) {\n\t\t\t\t\t\t// debugger;\n\t\t\t\t\t\tif (com.Passport.Pid in that.Vlt.messages) {\n\t\t\t\t\t\t\tthat.Vlt.messages[com.Passport.Pid](null, com);\n\t\t\t\t\t\t\tdelete that.Vlt.messages[com.Passport.Pid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t//debugger;\n\t\t\t\t\tthat.send(com, com.Passport.To, reply);\n\n\t\t\t\t\tfunction reply(err, cmd) {\n\t\t\t\t\t\t// console.log(\"--HttpReply\");\n\t\t\t\t\t\t// console.log(JSON.stringify(cmd));\n\t\t\t\t\t\t// console.log(JSON.stringify(com));\n\t\t\t\t\t\tif (cmd) {\n\t\t\t\t\t\t\tcom = cmd;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcom.Passport.Reply = true;\n\t\t\t\t\t\tvar str = JSON.stringify(com);\n\t\t\t\t\t\tsocket.send(str);\n\t\t\t\t\t}\n\n\t\t\t\t\t//.....................................getfile\n\t\t\t\t\t/// Read file from local directory\n\t\t\t\t\tfunction getfile() {\n\t\t\t\t\t\t//debugger;\n\t\t\t\t\t\tvar path = com.File;\n\t\t\t\t\t\tthat.getFile(path, function (err, data) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tconsole.log(' ** ERR', err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcom.Data = data.toString('utf8');\n\t\t\t\t\t\t\tvar str = com.Data;\n\t\t\t\t\t\t\tif ('Passport' in com)\n\t\t\t\t\t\t\t\tcom.Passport.Reply = true;\n\t\t\t\t\t\t\tvar str = JSON.stringify(com);\n\t\t\t\t\t\t\tsocket.send(str);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t//-------------------------------------------------------Publish\n\t// This is called when message needs to be sent to all\n\t// browsers that have subscribed\n\tfunction Publish(com, fun) {\n\t\t//debugger;\n\t\t// console.log('--Publish', com.Cmd);\n\t\tfun = fun || (() => { });\n\t\tvar Vlt = this.Vlt;\n\t\tvar socks = Vlt.Sockets;\n\t\tvar keys = Object.keys(socks);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar obj = socks[keys[i]];\n\t\t\tvar sock = obj.Socket;\n\t\t\tvar user = obj.User;\n\t\t\tif ('Publish' in user) {\n\t\t\t\tcom.Passport.To = user.Publish;\n\t\t\t\tif (fun) {\n\t\t\t\t\tcom.Passport.Disp = 'Query';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ('Forward' in com) {\n\t\t\t\tcom.Passport.To = com.Forward;\n\t\t\t\tif (fun) {\n\t\t\t\t\tif (!('messages' in this.Vlt)) this.Vlt.messages = {};\n\t\t\t\t\tthis.Vlt.messages[com.Passport.Pid] = fun;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar str = JSON.stringify(com);\n\t\t\tsock.send(str);\n\t\t}\n\t}\n\n\t//-------------------------------------------------------Get\n\t// Process GET request including authentication and\n\t// validation if required. If anything looks fishy, simply\n\t// ignore the request to confuse the hackers.\n\n\t//any HTTP Get accessible files should be stored in a ./static/ directory\n\tfunction Get(that, req, res) {\n\t\tlog.v('--Get', req.url);\n\t\tvar Par = that.Par;\n\t\tvar url = req.url;\n\t\tlet path = null;\n\n\t\tif (url.split(\".\").length > 1) {\n\t\t\tlet arr = url.split('/');\n\t\t\tarr = arr.slice(1);\n\n\t\t\tlet store = Par.Static||{};\n\n\t\t\tship(...subSearch(arr, store));\n\n\t\t\tfunction subSearch(ar, st) {\n\t\t\t\tif (ar[0] in st) {\n\t\t\t\t\tif (ar.length == 1) {\n\t\t\t\t\t\treturn [null, st[ar[0]]];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn subSearch(arr.slice(1), st[ar[0]]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlet err = `${url} does not exist in Par.Static`;\n\t\t\t\t\tlog.w(err);\n\t\t\t\t\treturn [err];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (url.charAt(0) == '/')\n\t\t\t\turl = url.substr(1);\n\t\t\tif (url==Par.Url)\n\t\t\t\tship(null, Par.HTML);\n\t\t\telse{\n\t\t\t\tres.writeHead(404);\n\t\t\t\tres.end('You are out of your verbial guord');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfunction ship(err, data) {\n\t\t\tif (err) {\n\t\t\t\tres.writeHead(404);\n\t\t\t\tres.end(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar page = data.toString();\n\t\t\tres.setHeader('Content-Type', 'text/html');\n\t\t\tres.end(page);\n\t\t}\n\t}\n\n\t//-----------------------------------------------------getModule\n\t// Retrieve module from module server\n\t// For now is retrieved from local file system\n\tfunction GetModule(com, fun) {\n\t\tlog.v('--Http/GetModule', com.Module);\n\t\t//console.log(JSON.stringify(com));\n\t\tvar that = this;\n\t\tvar zip = new jszip();\n\t\t//var dir = that.genPath(com.Module);\n\t\tvar man = [];\n\t\tthis.getModule(com.Module, function (err, mod) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** ERR:Cannot read module directory');\n\t\t\t\tif (fun)\n\t\t\t\t\tfun('Cannot read module directlry');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar str = JSON.stringify(mod);\n\t\t\t//console.log(\"mod is \", Object.keys(mod));\n\t\t\tzip.file('module.json', str, {\n\t\t\t\tdate: new Date(\"December 25, 2007 00:00:01\")\n\t\t\t\t//the date is required for zip consistency\n\t\t\t});\n\t\t\tman.push('module.json');\n\t\t\tzip.file('manifest.json', JSON.stringify(man), {\n\t\t\t\tdate: new Date(\"December 25, 2007 00:00:01\")\n\t\t\t\t//the date is required for zip consistency\n\t\t\t});\n\t\t\tzip.generateAsync({ type: 'base64' }).then(function (data) {\n\t\t\t\tcom.Zip = data;\n\t\t\t\tfun(null, com);\n\t\t\t});\n\t\t});\n\t}\n\n})();\n",
  "Nxs.js": "//# sourceURL=Nxs\n__Nexus = (function () {\n\tconsole.log(' ** Nxs executing');\n\n\twindow.log = {\n\t\t//grey magenta cyan yellow red\n\t\ti: (..._) => console.log(`%c[INFO] ${_.join(' ')}`, 'color: cyan')\n\n\t};\n\n\t// The defined log levels for outputting to the std.out() (ex. log.v(), log.d() ...)\n\t// Levels include:\n\t// v : verbose\n\t// d : debug\n\t// i : info\n\t// w : warn\n\t// e : error\n\twindow.log = {\n\t\tv: (...str) => console.log(`%c[VRBS] ${str.join(' ')}`, 'color: gray'),\n\t\td: (...str) => console.log(`%c[DBUG] ${str.join(' ')}`, 'color: magenta'),\n\t\ti: (...str) => console.log(`%c[INFO] ${str.join(' ')}`, 'color: cyan'),\n\t\tw: (...str) => console.log(`%c[WARN] ${str.join(' ')}`, 'color: yellow'),\n\t\te: (...str) => console.log(`%c[ERRR] ${str.join(' ')}`, 'color: red'),\n\t};\n\n\n\n\tvar SockIO;\n\tvar Root;\n\tvar Pid24;\n\tvar PidServer;\n\tvar PidNxs;\n\tvar PidTop;\n\tvar PidStart;\n\tvar Config;\n\tvar CurrentModule;\n\tvar Initializers = {};\n\tvar EntCache = {};\n\tvar ModCache = {};\n\tvar ModuleCache = {};\n\tvar ZipCache = {};\n\tvar SymTab = {};\n\tvar Css = [];\n\tvar Scripts = [];\n\tvar Fonts = {};\n\tvar Nxs = {\n\t\tgenPid: genPid,\n\t\tgenEntity: genEntity,\n\t\tdelEntity: delEntity,\n\t\tgenModule: genModule,\n\t\tgetFile,\n\t\tsend: send,\n\t\tgetFont: getFont\n\t};\n\tvar MsgFifo = [];\n\tvar MsgPool = {};\n\tvar that = this;\n\t__Config = {};\n\t__Config.TrackIO = false;\n\t__Share = {};\n\tlet silent = true;\n\n\treturn {\n\t\tstart: start,\n\t\tgenPid: genPid,\n\t\tgenModule: genModule,\n\t\tsend: send,\n\t\tgetFont: getFont\n\t};\n\n\tfunction start(sockio, cfg) {\n\t\tif (!silent) console.log('--Nxs/start');\n\t\tif (!silent) console.log('cfg', JSON.stringify(cfg, null, 2));\n\t\tPid24 = cfg.Pid24;\n\t\tPidServer = cfg.PidServer;\n\t\tSockIO = sockio;\n\t\tSockIO.removeListener('message');\n\t\tSockIO.on('message', function (data) {\n\t\t\t//debugger;\n\t\t\tvar cmd = JSON.parse(data);\n\t\t\tif (!silent) console.log(' << Msg:' + cmd.Cmd);\n\t\t\tif ('Passport' in cmd && cmd.Passport.Reply) {\n\t\t\t\tvar pid = cmd.Passport.Pid;\n\t\t\t\t//debugger;\n\t\t\t\tvar ixmsg = MsgFifo.indexOf(pid);\n\t\t\t\tif (ixmsg >= 0) {\n\t\t\t\t\tvar func = MsgPool[pid];\n\t\t\t\t\tdelete MsgPool[pid];\n\t\t\t\t\tMsgFifo.splice(ixmsg, 1);\n\t\t\t\t\tif (func) {\n\t\t\t\t\t\tfunc(null, cmd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Not reply, try to dispatch on browser\n\t\t\tvar pid = cmd.Passport.To;\n\t\t\tvar pid24 = pid.substr(0, 24);\n\t\t\tif (pid24 == Pid24) {\n\t\t\t\tif (pid in EntCache) {\n\t\t\t\t\tvar ent = EntCache[pid];\n\t\t\t\t\tif ('Disp' in cmd.Passport && cmd.Passport.Disp == 'Query')\n\t\t\t\t\t\tent.dispatch(cmd, reply);\n\t\t\t\t\telse\n\t\t\t\t\t\tent.dispatch(cmd, () => {\n\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(' ** ERR:Local', pid, 'not in Cache');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunction reply(err, cmd) {\n\t\t\t\tif (cmd == null)\n\t\t\t\t\treturn;\n\t\t\t\tif ('Passport' in cmd) {\n\t\t\t\t\tcmd.Passport.Reply = true;\n\t\t\t\t\tvar str = JSON.stringify(cmd);\n\t\t\t\t\tSockIO.send(str);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tGenesis(cfg);\n\t}\n\n\t//-----------------------------------------------------send\n\t// Can be called with 1, 2, or three arguments.\n\t//  1 - com sent to creating Nexus.\n\t//  2 - com sent to particular entity, no return\n\t//  3 - com sent to particular entity with callback\n\tfunction send(com, pid, fun) {\n\t\tif (!('Passport' in com))\n\t\t\tcom.Passport = {};\n\t\tvar pidmsg = genPid();\n\t\tcom.Passport.Pid = pidmsg;\n\n\t\tif (pid) {\n\t\t\tif (pid.charAt(0) == '$') {\n\t\t\t\tvar sym = pid.substr(1);\n\t\t\t\tif (sym in Root.Global)\n\t\t\t\t\tpid = Root.Global[sym];\n\t\t\t}\n\t\t\tcom.Passport.To = pid;\n\n\t\t\tif (pid.charAt(0) != '$') {\n\t\t\t\tvar pid24 = pid.substr(0, 24);\n\t\t\t\tif (pid24 == Pid24) {\n\t\t\t\t\tif (pid in EntCache) {\n\t\t\t\t\t\tvar ent = EntCache[pid];\n\t\t\t\t\t\tent.dispatch(com, fun);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(' ** ERR:Local', pid, 'not in Cache');\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (pid.substr(1) in SymTab) {\n\t\t\t\tpid = SymTab[pid.substr(1)];\n\t\t\t\tif (pid in EntCache) {\n\t\t\t\t\tvar ent = EntCache[pid];\n\t\t\t\t\tent.dispatch(com, fun);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(' ** ERR:Local', pid, 'not in Cache');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fun) {\n\t\t\t//debugger;\n\t\t\tMsgPool[pidmsg] = fun;\n\t\t\tMsgFifo.push(pidmsg);\n\t\t\tif (MsgFifo.length > 100) {\n\t\t\t\tvar kill = MsgFifo.shift();\n\t\t\t\tdelete MsgPool[kill];\n\t\t\t}\n\t\t}\n\t\tvar str = JSON.stringify(com);\n\t\tif (__Config.TrackIO)\n\t\t\tconsole.log(' >> Msg:' + com.Cmd);\n\t\tif (!(silent)) console.log(str)\n\t\tSockIO.send(str);\n\n\t\t// function sendLocal() {\n\t\t//     if (pid in EntCache) {\n\t\t//         var ent = EntCache[pid];\n\t\t//         ent.dispatch(com, fun);\n\t\t//     } else {\n\t\t//         console.log(' ** ERR:Local', pid, 'not in Cache');\n\t\t//     }\n\t\t// }\n\t}\n\n\n\tfunction getFile(module, filename, fun) {\n\t\tlet mod = ModuleCache[module];\n\t\t//console.log(Object.keys(ModCache[module]));\n\t\tif (filename in mod) {\n\t\t\tfun(null, mod[filename])\n\t\t\treturn;\n\t\t}\n\t\tlet err = `Error: File ${filename} does not exist in module ${module}`;\n\t\tfun(err);\n\t}\n\n\n\n\t//--------------------------------------------------------getFont\n\tfunction getFont(font) {\n\t\tif (font in Fonts)\n\t\t\treturn Fonts[font];\n\t}\n\n\t//--------------------------------------------------------Entity\n\t// Entity base class\n\tfunction Entity(nxs, mod, par) {\n\t\t//\tvar Nxs = nxs;\n\t\tvar Par = par;\n\t\tvar Mod = mod;\n\t\tvar Vlt = {};\n\n\t\treturn {\n\t\t\tPar: Par,\n\t\t\tMod: Mod,\n\t\t\tVlt: Vlt,\n\t\t\t//\t\tNxs: Nxs,\n\t\t\tdispatch: dispatch,\n\t\t\tsend: send,\n\t\t\tdeleteEntity: deleteEntity,\n\t\t\tgetPid: getPid,\n\t\t\tgetFile,\n\t\t\tgenModule: genModule\n\t\t};\n\n\t\t//-------------------------------------------------dispatch\n\t\t// This is used by Nexus to dispatch incoming messages.\n\t\t// It should not be used internally unless you have a\n\t\t// prediliction to talk to yourself =)\n\t\tfunction dispatch(com, fun) {\n\t\t\tvar disp = Mod.dispatch;\n\t\t\tif (com.Cmd in disp) {\n\t\t\t\tdisp[com.Cmd].call(this, com, fun);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ('*' in disp) {\n\t\t\t\tdisp['*'].call(this, com, fun);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//console.log(com.Cmd + ' unknown');\n\t\t\tif (fun)\n\t\t\t\tfun(com.Cmd + ' unknown');\n\t\t}\n\n\t\tfunction deleteEntity(fun) {\n\t\t\tnxs.delEntity(Par.Pid, fun);\n\t\t}\n\n\t\t//-------------------------------------------------getPid\n\t\t// Return Pid of entity\n\t\tfunction getPid() {\n\t\t\treturn Par.Pid;\n\t\t}\n\n\t\t//generate a module in the local system\n\t\tfunction genModule(mod, fun) {\n\t\t\tnxs.genModule(mod, fun);\n\t\t}\n\n\t\tfunction getFile(filename, fun) {\n\t\t\tnxs.getFile(Par.Module, filename, fun);\n\t\t}\n\n\t\t//-------------------------------------------------send\n\t\tfunction send(com, pid, fun) {\n\t\t\tcom.Passport = {};\n\t\t\tif (fun)\n\t\t\t\tcom.Passport.From = Par.Pid;\n\t\t\tcom.Passport.To = pid;\n\t\t\tnxs.send(com, pid, fun);\n\t\t}\n\n\t\t//-------------------------------------------------reply\n\t\t// Reply to a message previously received\n\t\tfunction reply(com, fun) {\n\n\t\t}\n\t}\n\n\t//-----------------------------------------------------genNode\n\t// Generate node from parameter object\n\tfunction genEntity(par, fun) {\n\t\t//\tconsole.log('--genEntity', par.Entity);\n\t\tvar name = par.Entity;\n\t\tif (name in ModCache) {\n\t\t\tvar mod = ModCache[name];\n\t\t\tvar pid = genPid();\n\t\t\tpar.Pid = pid;\n\t\t\tent = new Entity(Nxs, mod, par);\n\t\t\tif (ent) {\n\t\t\t\tEntCache[pid] = ent;\n\t\t\t\tif (par.$Browser) {\n\t\t\t\t\tSymTab[par.$Browser] = pid;\n\t\t\t\t}\n\t\t\t\tfun(null, ent);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfun('genEntity failed');\n\t\t\treturn;\n\t\t}\n\t\tvar com = {};\n\t\tcom.Cmd = 'GetEntityMod';\n\t\tvar name = par.Entity;\n\t\tcom.Name = name;\n\t\tsend(com, null, done);\n\n\t\tfunction done(err, com) {\n\t\t\tif (!('Mod' in com)) {\n\t\t\t\tvar errmsg = com.Name + 'module is not available';\n\t\t\t\tconsole.log(' ** ERR:' + errmsg);\n\t\t\t\tfun(err);\n\t\t\t}\n\t\t\tvar pid = genPid();\n\t\t\tpar.Pid = pid;\n\t\t\t// if\n\t\t\tvar mod = eval(com.Mod);\n\t\t\tvar ent = new Entity(Nxs, mod, par);\n\t\t\tif (ent) {\n\t\t\t\tModCache[name] = mod;\n\t\t\t\tEntCache[pid] = ent;\n\t\t\t\t//                if (par.$Browser) {\n\t\t\t\t//                \tSymTab[par.$Browser] = pid;\n\t\t\t\t//                }\n\t\t\t\tfun(null, ent);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfun('Entity creation failed');\n\t\t}\n\t}\n\n\t//-----------------------------------------------------delEntity\n\t// Generate node from parameter object\n\tfunction delEntity(pid, fun) {\n\t\tif (EntCache[pid]) {\n\t\t\tdelete EntCache[pid];\n\t\t\tconsole.log(pid, ' Deleted');\n\t\t\tif (fun) {\n\t\t\t\tfun(null)\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('Entity not found: ', pid);\n\t\t\tif (fun) {\n\t\t\t\tfun((\"Entity not found: \" + pid));\n\t\t\t}\n\t\t}\n\t}\n\n\t//------------------------------------------------------genPid\n\t// Generate Pid (pseudo-GUID)\n\tfunction genPid() {\n\t\tvar pid = Pid24;\n\t\tvar hexDigits = \"0123456789ABCDEF\";\n\t\tfor (var i = 0; i < 8; i++)\n\t\t\tpid += hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n\t\treturn pid;\n\t}\n\n\t//-------------------------------------------------genModule\n\t// This is the version used to install modules\n\t// after startup, such as web dashboards and such.\n\t// It provides for safe setup and start which is\n\t// handled by Nxs for modules instantiated initially.\n\tfunction genModule(mod, fun) {\n\t\tvar pidapx;\n\t\tInitializers = {};\n\t\taddModule(mod, setup);\n\n\t\tfunction setup(err, pid) {\n\t\t\t//\tconsole.log('pid', pid);\n\t\t\t//\tconsole.log('Initializers', Initializers);\n\t\t\tpidapx = pid;\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** genModule:' + err);\n\t\t\t\tfun(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ('Setup' in Initializers) {\n\t\t\t\tvar q = {};\n\t\t\t\tq.Cmd = Initializers.Setup;\n\t\t\t\tsend(q, pidapx, start);\n\t\t\t} else {\n\t\t\t\tstart();\n\t\t\t}\n\t\t}\n\n\t\tfunction start(err, r) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** genModule:' + err);\n\t\t\t\tfun(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ('Start' in Initializers) {\n\t\t\t\tvar q = {};\n\t\t\t\tq.Cmd = Initializers.Start;\n\t\t\t\tsend(q, pidapx, pau);\n\t\t\t} else {\n\t\t\t\tpau();\n\t\t\t}\n\t\t}\n\n\t\tfunction pau(err, r) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** genModule:' + err);\n\t\t\t}\n\t\t\tfun(err, pidapx);\n\t\t}\n\n\t}\n\n\t//-------------------------------------------------addModule\n\tfunction addModule(mod, fun) {\n\t\tif (!(silent)) console.log('..addModule');\n\t\tif (!(silent)) console.log(JSON.stringify(mod, null, 2));\n\t\tvar ents = {};\n\t\tvar lbls = {};\n\t\tvar q = {};\n\t\tlet modjson = null\n\t\tq.Cmd = 'GetModule';\n\t\tq.Module = mod.Module;\n\t\tif (!(silent)) console.log(q);\n\t\tsend(q, PidServer, addmod);\n\n\t\tfunction addmod(err, r) {\n\t\t\t//console.log('..addmod');\n\t\t\tvar module = r.Module;\n\t\t\tvar zipmod = new JSZip();\n\t\t\tzipmod.loadAsync(r.Zip, { base64: true }).then(function (zip) {\n\t\t\t\tvar dir = zipmod.file(/.*./);\n\n\t\t\t\tzip.file('module.json').async('string').then(function (str) {\n\t\t\t\t\tmodjson = JSON.parse(str);\n\t\t\t\t\tModuleCache[mod.Module] = modjson;\n\t\t\t\t\tvar keys = Object.keys(mod);\n\t\t\t\t\t//debugger;\n\t\t\t\t\tstyles();\n\t\t\t\t});\n\n\n\t\t\t\tfunction styles() {\n\t\t\t\t\tif ('styles.json' in modjson) {\n\t\t\t\t\t\tvar obj = JSON.parse(modjson[\"styles.json\"]);\n\t\t\t\t\t\tvar keys = Object.keys(obj);\n\t\t\t\t\t\t//debugger;\n\t\t\t\t\t\tasync.eachSeries(keys, function (key, func) {\n\t\t\t\t\t\t\t//debugger;\n\n\t\t\t\t\t\t\t//this needs to be reworked duplicate names are not loaded\n\t\t\t\t\t\t\t// if(Css.indexOf(key) >= 0) {\n\t\t\t\t\t\t\t// \tfunc();\n\t\t\t\t\t\t\t// \treturn;\n\t\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t\tCss.push(key);\n\t\t\t\t\t\t\tvar file = obj[key];\n\n\t\t\t\t\t\t\tlet css = modjson[file];\n\t\t\t\t\t\t\t//console.log(\"Css is \", css);\n\t\t\t\t\t\t\tvar tag = document.createElement('style');\n\t\t\t\t\t\t\ttag.setAttribute(\"data-css-url\", key);\n\t\t\t\t\t\t\ttag.setAttribute(\"type\", 'text/css');\n\t\t\t\t\t\t\ttag.innerHTML = css;\n\t\t\t\t\t\t\tdocument.head.appendChild(tag);\n\t\t\t\t\t\t\t// var txt = document.createTextNode(css);\n\t\t\t\t\t\t\t// tag.appendChild(txt);\n\t\t\t\t\t\t\t// document.head.appendChild(tag);\n\n\t\t\t\t\t\t\t/*\tvar tag = document.createElement('script');\n\t\t\t\t\t\t\t\ttag.setAttribute(\"data-script-url\", key);\n\t\t\t\t\t\t\t\ttag.setAttribute(\"type\", 'text/javascript');\n\t\t\t\t\t\t\t\tvar txt = document.createTextNode(scr);\n\t\t\t\t\t\t\t\ttag.appendChild(txt);\n\t\t\t\t\t\t\t\tdocument.head.appendChild(tag); */\n\t\t\t\t\t\t\tfunc();\n\t\t\t\t\t\t}, scripts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscripts();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction scripts() {\n\t\t\t\t\t//console.log('..scripts');\n\t\t\t\t\tif ('scripts.json' in modjson) {\n\t\t\t\t\t\tvar obj = JSON.parse(modjson[\"scripts.json\"]);\n\t\t\t\t\t\tvar keys = Object.keys(obj);\n\t\t\t\t\t\tasync.eachSeries(keys, function (key, func) {\n\t\t\t\t\t\t\tif (Scripts.indexOf(key) >= 0) {\n\t\t\t\t\t\t\t\tfunc();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tScripts.push(key);\n\t\t\t\t\t\t\tvar file = obj[key];\n\t\t\t\t\t\t\tlet scr = modjson[file];\n\t\t\t\t\t\t\t//console.log(\"loading module from \", module, scr);\n\n\t\t\t\t\t\t\t// var tag = document.createElement('script');\n\t\t\t\t\t\t\t// tag.setAttribute(\"data-script-url\", key);\n\t\t\t\t\t\t\t// tag.setAttribute(\"type\", 'text/javascript');\n\t\t\t\t\t\t\t// var txt = document.createTextNode(scr);\n\t\t\t\t\t\t\t// tag.appendChild(txt);\n\t\t\t\t\t\t\t// document.head.appendChild(tag);\n\t\t\t\t\t\t\teval(scr);\n\t\t\t\t\t\t\tconsole.log(\"Evaled scr\", file);\n\t\t\t\t\t\t\tfunc();\n\t\t\t\t\t\t}, fonts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfonts();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction fonts() {\n\t\t\t\t\t//\tconsole.log('..fonts');\n\t\t\t\t\tif ('fonts.json' in modjson) {\n\t\t\t\t\t\tvar obj = JSON.parse(modjson[\"fonts.json\"]);\n\t\t\t\t\t\tvar keys = Object.keys(obj);\n\t\t\t\t\t\tasync.eachSeries(keys, function (key, func) {\n\t\t\t\t\t\t\tif (key in Fonts) {\n\t\t\t\t\t\t\t\tfunc();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar file = obj[key];\n\t\t\t\t\t\t\tlet str = modjson[file];\n\t\t\t\t\t\t\tvar json = JSON.parse(str);\n\t\t\t\t\t\t\tvar font = new THREE.Font(json);\n\t\t\t\t\t\t\tif (!silent) console.log('font', font);\n\t\t\t\t\t\t\tFonts[key] = font;\n\t\t\t\t\t\t\tfunc();\n\t\t\t\t\t\t}, schema);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tschema();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction schema() {\n\t\t\t\t\t//console.log('..schema');\n\t\t\t\t\tlet str = JSON.parse(modjson[\"schema.json\"]);\n\t\t\t\t\tcompile(str);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfunction compile(str) {\n\t\t\t\t//\tconsole.log('..compile');\n\t\t\t\tvar pidapx;\n\t\t\t\tvar schema = str;\n\t\t\t\tZipCache[module] = zipmod;\n\t\t\t\t//debugger;\n\t\t\t\tfor (let lbl in schema) {\n\t\t\t\t\tvar ent = schema[lbl];\n\t\t\t\t\tif ('Par' in mod) {\n\t\t\t\t\t\tfor (key in mod.Par) {\n\t\t\t\t\t\t\tent[key] = mod.Par[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tent.Module = mod.Module;\n\t\t\t\t\t//Note: CurrentModule is only used in initial processing\n\t\t\t\t\t//      of browser.json\n\t\t\t\t\tif (lbl == 'Apex') {\n\t\t\t\t\t\tif (CurrentModule)\n\t\t\t\t\t\t\tent.Pid = Root.ApexList[CurrentModule];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tent.Pid = genPid();\n\t\t\t\t\t\tpidapx = ent.Pid;\n\t\t\t\t\t\t//\tconsole.log('Apex', ent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tent.Pid = genPid();\n\t\t\t\t\t}\n\t\t\t\t\tlbls[lbl] = ent.Pid;\n\t\t\t\t\tents[lbl] = ent;\n\t\t\t\t}\n\t\t\t\tvar keys = Object.keys(ents);\n\t\t\t\tvar nkey = keys.length;\n\t\t\t\tvar ikey = 0;\n\t\t\t\tnextent();\n\n\t\t\t\tfunction nextent() {\n\t\t\t\t\tif (ikey >= nkey) {\n\t\t\t\t\t\tfun(null, pidapx);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar key = keys[ikey];\n\t\t\t\t\tvar ent = ents[key];\n\n\t\t\t\t\t//The below seems to be duplicate code from 484-488\n\n\t\t\t\t\t// if('Par' in mod) {\n\t\t\t\t\t// \tfor(key in mod.Par) {\n\t\t\t\t\t// \t\tent[key] = mod.Par[key];\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\tikey++;\n\t\t\t\t\tfor (let key in ent) {\n\t\t\t\t\t\tval = ent[key];\n\t\t\t\t\t\tif (key == '$Setup') {\n\t\t\t\t\t\t\t//it looks like only one setup will be called. should be an array..\n\t\t\t\t\t\t\tInitializers.Setup = ent[key];\n\t\t\t\t\t\t\tRoot.Setup[ent.Pid.substr(24)] = ent[key];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (key == '$Start') {\n\t\t\t\t\t\t\t//it looks like only one start will be called. should be an array..\n\t\t\t\t\t\t\tInitializers.Start = ent[key];\n\t\t\t\t\t\t\tRoot.Start[ent.Pid.substr(24)] = ent[key];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfunction recurseSymbol(obj) {\n\n\t\t\t\t\t\t\tif (typeof obj == 'string')\n\t\t\t\t\t\t\t\treturn symbol(obj);\n\t\t\t\t\t\t\tif (typeof obj == 'object') {\n\t\t\t\t\t\t\t\tfor (let sym in obj) {\n\t\t\t\t\t\t\t\t\tobj[sym] = recurseSymbol(obj[sym]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn obj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tent[key] = recurseSymbol(ent[key]);\n\t\t\t\t\t}\n\t\t\t\t\tvar modkey = ent.Module + '/' + ent.Entity;\n\n\t\t\t\t\t//seems to be duplicate from line 481\n\n\t\t\t\t\t//ZipCache[mod] = zipmod;\n\t\t\t\t\tlet str = modjson[ent.Entity]\n\t\t\t\t\tvar mod = eval(str);\n\t\t\t\t\tModCache[modkey] = mod;\n\t\t\t\t\tEntCache[ent.Pid] = new Entity(Nxs, mod, ent);\n\t\t\t\t\tnextent();\n\t\t\t\t}\n\n\t\t\t\tfunction symbol(str) {\n\t\t\t\t\tvar esc = str.charAt(0);\n\t\t\t\t\tif (esc == '#') {\n\t\t\t\t\t\tvar lbl = str.substr(1);\n\t\t\t\t\t\tif (!(lbl in lbls)) {\n\t\t\t\t\t\t\tvar err = ' ** Symbol ' + lbl + ' not defined';\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn lbls[lbl];\n\t\t\t\t\t}\n\t\t\t\t\tif (esc == '$') {\n\t\t\t\t\t\tvar sym = str.substr(1);\n\t\t\t\t\t\tif (!(sym in Root.ApexList)) {\n\t\t\t\t\t\t\tvar err = ' ** Symbol ' + sym + ' not defined';\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Root.ApexList[sym];\n\t\t\t\t\t}\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//-----------------------------------------------------Genesis\n\t// Create cache if it does nto exist and populate\n\t// This is called only once when a new systems is\n\t// first instantiated\n\tfunction Genesis(cfg) {\n\t\tif (!silent) console.log('--Nxs/Genesis');\n\t\tConfig = cfg;\n\t\tRoot = {};\n\t\tRoot.Global = {};\n\t\tRoot.Setup = {};\n\t\tRoot.Start = {};\n\t\tRoot.ApexList = cfg.ApexList || {};\n\t\tvar ikey = 0;\n\t\tif ('Scripts' in Config) {\n\t\t\tvar keys = Object.keys(Config.Scripts);\n\t\t\tnkeys = keys.length;\n\t\t} else {\n\t\t\tnkeys = 0;\n\t\t}\n\t\tif (!silent) console.log('Scripts', nkeys, Config.Scripts);\n\t\tnextscript();\n\n\t\tfunction nextscript() {\n\t\t\t//\tconsole.log('..nextscript');\n\t\t\tif (ikey >= nkeys) {\n\t\t\t\tmodules();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar key = keys[ikey];\n\t\t\tikey++;\n\t\t\tvar q = {};\n\t\t\tq.Cmd = 'GetFile';\n\t\t\tq.File = Config.Scripts[key];\n\t\t\tsend(q, Config.pidServer, function (err, r) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(' ** ERR:Script error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tscript(key, r.Data);\n\t\t\t});\n\n\t\t\tfunction script(url, data) {\n\t\t\t\tvar tag = document.createElement('script');\n\t\t\t\ttag.setAttribute(\"data-script-url\", url);\n\t\t\t\ttag.setAttribute(\"type\", 'text/javascript');\n\t\t\t\tvar txt = document.createTextNode(data);\n\t\t\t\ttag.appendChild(txt);\n\t\t\t\tdocument.head.appendChild(tag);\n\t\t\t\tnextscript();\n\t\t\t}\n\t\t}\n\n\t\t//.................................................modules\n\t\tfunction modules() {\n\t\t\tvar keys = Object.keys(Config.Modules);\n\t\t\t//debugger;\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tRoot.ApexList[key] = genPid();\n\t\t\t}\n\t\t\tasync.eachSeries(keys, function (key, func) {\n\t\t\t\tlet mod = Config.Modules[key];\n\t\t\t\tCurrentModule = key;\n\t\t\t\taddModule(mod, addmod);\n\n\t\t\t\tfunction addmod(err, pid) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tconsole.log(' ** ERR:Cannot add mod <' + r.Module + '>');\n\t\t\t\t\t}\n\t\t\t\t\t//TBD: Might want to bail on err\n\t\t\t\t\tconsole.log('Apex', key, '<=', pid);\n\t\t\t\t\tfunc();\n\t\t\t\t}\n\t\t\t}, Setup);\n\n\t\t}\n\n\t\t//-------------------------------------------------Setup\n\t\tfunction Setup(err) {\n\t\t\t// console.log('--Nexus/Setup');\n\n\t\t\tCurrentModule = null;\n\t\t\tvar pids = Object.keys(Root.Setup);\n\t\t\tvar npid = pids.length;\n\t\t\tvar ipid = 0;\n\t\t\tsetup();\n\n\t\t\tfunction setup() {\n\t\t\t\tif (ipid >= npid) {\n\t\t\t\t\tStart();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar pid8 = pids[ipid];\n\t\t\t\tipid++;\n\t\t\t\tvar q = {};\n\t\t\t\tq.Cmd = Root.Setup[pid8];\n\t\t\t\tvar pid = Pid24 + pid8;\n\t\t\t\tsend(q, pid, done);\n\n\t\t\t\tfunction done(err, r) {\n\t\t\t\t\tsetup();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//-----------------------------------------------------Start\n\t\tfunction Start() {\n\t\t\tconsole.log('--Nxs/Start');\n\t\t\tvar pids = Object.keys(Root.Start);\n\t\t\tvar npid = pids.length;\n\t\t\tvar ipid = 0;\n\t\t\tstart();\n\n\t\t\tfunction start() {\n\t\t\t\tif (ipid >= npid) {\n\t\t\t\t\tRun();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar pid8 = pids[ipid];\n\t\t\t\tipid++;\n\t\t\t\tvar q = {};\n\t\t\t\tq.Cmd = Root.Start[pid8];\n\t\t\t\tvar pid = Pid24 + pid8;\n\t\t\t\t//console.log(\"start \", pid);\n\t\t\t\tsend(q, pid, done);\n\n\t\t\t\tfunction done(err, r) {\n\t\t\t\t\t//console.log(\"Return start \", pid);\n\t\t\t\t\tstart();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//-------------------------------------------------Run\n\t\tfunction Run() {\n\t\t\tconsole.log('--Nxs/Run');\n\t\t}\n\t}\n\n})();\n",
  "async.js": "(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t\t(factory((global.async = global.async || {})));\n}(this, (function (exports) {\n\t'use strict';\n\n\tfunction slice(arrayLike, start) {\n\t\tstart = start | 0;\n\t\tvar newLen = Math.max(arrayLike.length - start, 0);\n\t\tvar newArr = Array(newLen);\n\t\tfor (var idx = 0; idx < newLen; idx++) {\n\t\t\tnewArr[idx] = arrayLike[start + idx];\n\t\t}\n\t\treturn newArr;\n\t}\n\n\tvar initialParams = function (fn) {\n\t\treturn function (/*...args, callback*/) {\n\t\t\tvar args = slice(arguments);\n\t\t\tvar callback = args.pop();\n\t\t\tfn.call(this, args, callback);\n\t\t};\n\t};\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t\tvar type = typeof value;\n\t\treturn value != null && (type == 'object' || type == 'function');\n\t}\n\n\tvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\n\tvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\n\tfunction fallback(fn) {\n\t\tsetTimeout(fn, 0);\n\t}\n\n\tfunction wrap(defer) {\n\t\treturn function (fn/*, ...args*/) {\n\t\t\tvar args = slice(arguments, 1);\n\t\t\tdefer(function () {\n\t\t\t\tfn.apply(null, args);\n\t\t\t});\n\t\t};\n\t}\n\n\tvar _defer;\n\n\tif (hasSetImmediate) {\n\t\t_defer = setImmediate;\n\t} else if (hasNextTick) {\n\t\t_defer = process.nextTick;\n\t} else {\n\t\t_defer = fallback;\n\t}\n\n\tvar setImmediate$1 = wrap(_defer);\n\n\t/**\n\t * Take a sync function and make it async, passing its return value to a\n\t * callback. This is useful for plugging sync functions into a waterfall,\n\t * series, or other async functions. Any arguments passed to the generated\n\t * function will be passed to the wrapped function (except for the final\n\t * callback argument). Errors thrown will be passed to the callback.\n\t *\n\t * If the function passed to `asyncify` returns a Promise, that promises's\n\t * resolved/rejected state will be used to call the callback, rather than simply\n\t * the synchronous return value.\n\t *\n\t * This also means you can asyncify ES2017 `async` functions.\n\t *\n\t * @name asyncify\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @alias wrapSync\n\t * @category Util\n\t * @param {Function} func - The synchronous function, or Promise-returning\n\t * function to convert to an {@link AsyncFunction}.\n\t * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n\t * invoked with `(args..., callback)`.\n\t * @example\n\t *\n\t * // passing a regular synchronous function\n\t * async.waterfall([\n\t *     async.apply(fs.readFile, filename, \"utf8\"),\n\t *     async.asyncify(JSON.parse),\n\t *     function (data, next) {\n\t *         // data is the result of parsing the text.\n\t *         // If there was a parsing error, it would have been caught.\n\t *     }\n\t * ], callback);\n\t *\n\t * // passing a function returning a promise\n\t * async.waterfall([\n\t *     async.apply(fs.readFile, filename, \"utf8\"),\n\t *     async.asyncify(function (contents) {\n\t *         return db.model.create(contents);\n\t *     }),\n\t *     function (model, next) {\n\t *         // `model` is the instantiated model object.\n\t *         // If there was an error, this function would be skipped.\n\t *     }\n\t * ], callback);\n\t *\n\t * // es2017 example, though `asyncify` is not needed if your JS environment\n\t * // supports async functions out of the box\n\t * var q = async.queue(async.asyncify(async function(file) {\n\t *     var intermediateStep = await processFile(file);\n\t *     return await somePromise(intermediateStep)\n\t * }));\n\t *\n\t * q.push(files);\n\t */\n\tfunction asyncify(func) {\n\t\treturn initialParams(function (args, callback) {\n\t\t\tvar result;\n\t\t\ttry {\n\t\t\t\tresult = func.apply(this, args);\n\t\t\t} catch (e) {\n\t\t\t\treturn callback(e);\n\t\t\t}\n\t\t\t// if result is Promise object\n\t\t\tif (isObject(result) && typeof result.then === 'function') {\n\t\t\t\tresult.then(function (value) {\n\t\t\t\t\tinvokeCallback(callback, null, value);\n\t\t\t\t}, function (err) {\n\t\t\t\t\tinvokeCallback(callback, err.message ? err : new Error(err));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction invokeCallback(callback, error, value) {\n\t\ttry {\n\t\t\tcallback(error, value);\n\t\t} catch (e) {\n\t\t\tsetImmediate$1(rethrow, e);\n\t\t}\n\t}\n\n\tfunction rethrow(error) {\n\t\tthrow error;\n\t}\n\n\tvar supportsSymbol = typeof Symbol === 'function';\n\n\tfunction isAsync(fn) {\n\t\treturn supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n\t}\n\n\tfunction wrapAsync(asyncFn) {\n\t\treturn isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n\t}\n\n\tfunction applyEach$1(eachfn) {\n\t\treturn function (fns/*, ...args*/) {\n\t\t\tvar args = slice(arguments, 1);\n\t\t\tvar go = initialParams(function (args, callback) {\n\t\t\t\tvar that = this;\n\t\t\t\treturn eachfn(fns, function (fn, cb) {\n\t\t\t\t\twrapAsync(fn).apply(that, args.concat(cb));\n\t\t\t\t}, callback);\n\t\t\t});\n\t\t\tif (args.length) {\n\t\t\t\treturn go.apply(this, args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn go;\n\t\t\t}\n\t\t};\n\t}\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\n\t/** Built-in value references. */\n\tvar Symbol$1 = root.Symbol;\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString = objectProto.toString;\n\n\t/** Built-in value references. */\n\tvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n\t/**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */\n\tfunction getRawTag(value) {\n\t\tvar isOwn = hasOwnProperty.call(value, symToStringTag$1),\n\t\t\ttag = value[symToStringTag$1];\n\n\t\ttry {\n\t\t\tvalue[symToStringTag$1] = undefined;\n\t\t\tvar unmasked = true;\n\t\t} catch (e) { }\n\n\t\tvar result = nativeObjectToString.call(value);\n\t\tif (unmasked) {\n\t\t\tif (isOwn) {\n\t\t\t\tvalue[symToStringTag$1] = tag;\n\t\t\t} else {\n\t\t\t\tdelete value[symToStringTag$1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$1 = Object.prototype;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString$1 = objectProto$1.toString;\n\n\t/**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */\n\tfunction objectToString(value) {\n\t\treturn nativeObjectToString$1.call(value);\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar nullTag = '[object Null]';\n\tvar undefinedTag = '[object Undefined]';\n\n\t/** Built-in value references. */\n\tvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n\t/**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tfunction baseGetTag(value) {\n\t\tif (value == null) {\n\t\t\treturn value === undefined ? undefinedTag : nullTag;\n\t\t}\n\t\tvalue = Object(value);\n\t\treturn (symToStringTag && symToStringTag in value)\n\t\t\t? getRawTag(value)\n\t\t\t: objectToString(value);\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar asyncTag = '[object AsyncFunction]';\n\tvar funcTag = '[object Function]';\n\tvar genTag = '[object GeneratorFunction]';\n\tvar proxyTag = '[object Proxy]';\n\n\t/**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */\n\tfunction isFunction(value) {\n\t\tif (!isObject(value)) {\n\t\t\treturn false;\n\t\t}\n\t\t// The use of `Object#toString` avoids issues with the `typeof` operator\n\t\t// in Safari 9 which returns 'object' for typed arrays and other constructors.\n\t\tvar tag = baseGetTag(value);\n\t\treturn tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This method is loosely based on\n\t * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t * @example\n\t *\n\t * _.isLength(3);\n\t * // => true\n\t *\n\t * _.isLength(Number.MIN_VALUE);\n\t * // => false\n\t *\n\t * _.isLength(Infinity);\n\t * // => false\n\t *\n\t * _.isLength('3');\n\t * // => false\n\t */\n\tfunction isLength(value) {\n\t\treturn typeof value == 'number' &&\n\t\t\tvalue > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\n\t/**\n\t * Checks if `value` is array-like. A value is considered array-like if it's\n\t * not a function and has a `value.length` that's an integer greater than or\n\t * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t * @example\n\t *\n\t * _.isArrayLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArrayLike(document.body.children);\n\t * // => true\n\t *\n\t * _.isArrayLike('abc');\n\t * // => true\n\t *\n\t * _.isArrayLike(_.noop);\n\t * // => false\n\t */\n\tfunction isArrayLike(value) {\n\t\treturn value != null && isLength(value.length) && !isFunction(value);\n\t}\n\n\t// A temporary value used to identify if the loop should be broken.\n\t// See #1064, #1293\n\tvar breakLoop = {};\n\n\t/**\n\t * This method returns `undefined`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.3.0\n\t * @category Util\n\t * @example\n\t *\n\t * _.times(2, _.noop);\n\t * // => [undefined, undefined]\n\t */\n\tfunction noop() {\n\t\t// No operation performed.\n\t}\n\n\tfunction once(fn) {\n\t\treturn function () {\n\t\t\tif (fn === null) return;\n\t\t\tvar callFn = fn;\n\t\t\tfn = null;\n\t\t\tcallFn.apply(this, arguments);\n\t\t};\n\t}\n\n\tvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\n\tvar getIterator = function (coll) {\n\t\treturn iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n\t};\n\n\t/**\n\t * The base implementation of `_.times` without support for iteratee shorthands\n\t * or max array length checks.\n\t *\n\t * @private\n\t * @param {number} n The number of times to invoke `iteratee`.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the array of results.\n\t */\n\tfunction baseTimes(n, iteratee) {\n\t\tvar index = -1,\n\t\t\tresult = Array(n);\n\n\t\twhile (++index < n) {\n\t\t\tresult[index] = iteratee(index);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t\treturn value != null && typeof value == 'object';\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]';\n\n\t/**\n\t * The base implementation of `_.isArguments`.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t */\n\tfunction baseIsArguments(value) {\n\t\treturn isObjectLike(value) && baseGetTag(value) == argsTag;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$3 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n\t/**\n\t * Checks if `value` is likely an `arguments` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t *  else `false`.\n\t * @example\n\t *\n\t * _.isArguments(function() { return arguments; }());\n\t * // => true\n\t *\n\t * _.isArguments([1, 2, 3]);\n\t * // => false\n\t */\n\tvar isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {\n\t\treturn isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n\t\t\t!propertyIsEnumerable.call(value, 'callee');\n\t};\n\n\t/**\n\t * Checks if `value` is classified as an `Array` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n\t * @example\n\t *\n\t * _.isArray([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArray(document.body.children);\n\t * // => false\n\t *\n\t * _.isArray('abc');\n\t * // => false\n\t *\n\t * _.isArray(_.noop);\n\t * // => false\n\t */\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * This method returns `false`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {boolean} Returns `false`.\n\t * @example\n\t *\n\t * _.times(2, _.stubFalse);\n\t * // => [false, false]\n\t */\n\tfunction stubFalse() {\n\t\treturn false;\n\t}\n\n\t/** Detect free variable `exports`. */\n\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n\t/** Built-in value references. */\n\tvar Buffer = moduleExports ? root.Buffer : undefined;\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n\t/**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */\n\tvar isBuffer = nativeIsBuffer || stubFalse;\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n\t/** Used to detect unsigned integer values. */\n\tvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t\tlength = length == null ? MAX_SAFE_INTEGER$1 : length;\n\t\treturn !!length &&\n\t\t\t(typeof value == 'number' || reIsUint.test(value)) &&\n\t\t\t(value > -1 && value % 1 == 0 && value < length);\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar argsTag$1 = '[object Arguments]';\n\tvar arrayTag = '[object Array]';\n\tvar boolTag = '[object Boolean]';\n\tvar dateTag = '[object Date]';\n\tvar errorTag = '[object Error]';\n\tvar funcTag$1 = '[object Function]';\n\tvar mapTag = '[object Map]';\n\tvar numberTag = '[object Number]';\n\tvar objectTag = '[object Object]';\n\tvar regexpTag = '[object RegExp]';\n\tvar setTag = '[object Set]';\n\tvar stringTag = '[object String]';\n\tvar weakMapTag = '[object WeakMap]';\n\n\tvar arrayBufferTag = '[object ArrayBuffer]';\n\tvar dataViewTag = '[object DataView]';\n\tvar float32Tag = '[object Float32Array]';\n\tvar float64Tag = '[object Float64Array]';\n\tvar int8Tag = '[object Int8Array]';\n\tvar int16Tag = '[object Int16Array]';\n\tvar int32Tag = '[object Int32Array]';\n\tvar uint8Tag = '[object Uint8Array]';\n\tvar uint8ClampedTag = '[object Uint8ClampedArray]';\n\tvar uint16Tag = '[object Uint16Array]';\n\tvar uint32Tag = '[object Uint32Array]';\n\n\t/** Used to identify `toStringTag` values of typed arrays. */\n\tvar typedArrayTags = {};\n\ttypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t\ttypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t\ttypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t\ttypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t\ttypedArrayTags[uint32Tag] = true;\n\ttypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\n\t\ttypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t\ttypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n\t\ttypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\n\t\ttypedArrayTags[mapTag] = typedArrayTags[numberTag] =\n\t\ttypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n\t\ttypedArrayTags[setTag] = typedArrayTags[stringTag] =\n\t\ttypedArrayTags[weakMapTag] = false;\n\n\t/**\n\t * The base implementation of `_.isTypedArray` without Node.js optimizations.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t */\n\tfunction baseIsTypedArray(value) {\n\t\treturn isObjectLike(value) &&\n\t\t\tisLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n\t}\n\n\t/**\n\t * The base implementation of `_.unary` without support for storing metadata.\n\t *\n\t * @private\n\t * @param {Function} func The function to cap arguments for.\n\t * @returns {Function} Returns the new capped function.\n\t */\n\tfunction baseUnary(func) {\n\t\treturn function (value) {\n\t\t\treturn func(value);\n\t\t};\n\t}\n\n\t/** Detect free variable `exports`. */\n\tvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n\t/** Detect free variable `module`. */\n\tvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n\t/** Detect free variable `process` from Node.js. */\n\tvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n\t/** Used to access faster Node.js helpers. */\n\tvar nodeUtil = (function () {\n\t\ttry {\n\t\t\treturn freeProcess && freeProcess.binding('util');\n\t\t} catch (e) { }\n\t}());\n\n\t/* Node.js helper references. */\n\tvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n\t/**\n\t * Checks if `value` is classified as a typed array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t * @example\n\t *\n\t * _.isTypedArray(new Uint8Array);\n\t * // => true\n\t *\n\t * _.isTypedArray([]);\n\t * // => false\n\t */\n\tvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n\t/** Used for built-in method references. */\n\tvar objectProto$2 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n\t/**\n\t * Creates an array of the enumerable property names of the array-like `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @param {boolean} inherited Specify returning inherited property names.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction arrayLikeKeys(value, inherited) {\n\t\tvar isArr = isArray(value),\n\t\t\tisArg = !isArr && isArguments(value),\n\t\t\tisBuff = !isArr && !isArg && isBuffer(value),\n\t\t\tisType = !isArr && !isArg && !isBuff && isTypedArray(value),\n\t\t\tskipIndexes = isArr || isArg || isBuff || isType,\n\t\t\tresult = skipIndexes ? baseTimes(value.length, String) : [],\n\t\t\tlength = result.length;\n\n\t\tfor (var key in value) {\n\t\t\tif ((inherited || hasOwnProperty$1.call(value, key)) &&\n\t\t\t\t!(skipIndexes && (\n\t\t\t\t\t// Safari 9 has enumerable `arguments.length` in strict mode.\n\t\t\t\t\tkey == 'length' ||\n\t\t\t\t\t// Node.js 0.10 has enumerable non-index properties on buffers.\n\t\t\t\t\t(isBuff && (key == 'offset' || key == 'parent')) ||\n\t\t\t\t\t// PhantomJS 2 has enumerable non-index properties on typed arrays.\n\t\t\t\t\t(isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n\t\t\t\t\t// Skip index properties.\n\t\t\t\t\tisIndex(key, length)\n\t\t\t\t))) {\n\t\t\t\tresult.push(key);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$5 = Object.prototype;\n\n\t/**\n\t * Checks if `value` is likely a prototype object.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t */\n\tfunction isPrototype(value) {\n\t\tvar Ctor = value && value.constructor,\n\t\t\tproto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n\t\treturn value === proto;\n\t}\n\n\t/**\n\t * Creates a unary function that invokes `func` with its argument transformed.\n\t *\n\t * @private\n\t * @param {Function} func The function to wrap.\n\t * @param {Function} transform The argument transform.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction overArg(func, transform) {\n\t\treturn function (arg) {\n\t\t\treturn func(transform(arg));\n\t\t};\n\t}\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeKeys = overArg(Object.keys, Object);\n\n\t/** Used for built-in method references. */\n\tvar objectProto$4 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n\t/**\n\t * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction baseKeys(object) {\n\t\tif (!isPrototype(object)) {\n\t\t\treturn nativeKeys(object);\n\t\t}\n\t\tvar result = [];\n\t\tfor (var key in Object(object)) {\n\t\t\tif (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n\t\t\t\tresult.push(key);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates an array of the own enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects. See the\n\t * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t * for more details.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keys(new Foo);\n\t * // => ['a', 'b'] (iteration order is not guaranteed)\n\t *\n\t * _.keys('hi');\n\t * // => ['0', '1']\n\t */\n\tfunction keys(object) {\n\t\treturn isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n\t}\n\n\tfunction createArrayIterator(coll) {\n\t\tvar i = -1;\n\t\tvar len = coll.length;\n\t\treturn function next() {\n\t\t\treturn ++i < len ? { value: coll[i], key: i } : null;\n\t\t}\n\t}\n\n\tfunction createES2015Iterator(iterator) {\n\t\tvar i = -1;\n\t\treturn function next() {\n\t\t\tvar item = iterator.next();\n\t\t\tif (item.done)\n\t\t\t\treturn null;\n\t\t\ti++;\n\t\t\treturn { value: item.value, key: i };\n\t\t}\n\t}\n\n\tfunction createObjectIterator(obj) {\n\t\tvar okeys = keys(obj);\n\t\tvar i = -1;\n\t\tvar len = okeys.length;\n\t\treturn function next() {\n\t\t\tvar key = okeys[++i];\n\t\t\treturn i < len ? { value: obj[key], key: key } : null;\n\t\t};\n\t}\n\n\tfunction iterator(coll) {\n\t\tif (isArrayLike(coll)) {\n\t\t\treturn createArrayIterator(coll);\n\t\t}\n\n\t\tvar iterator = getIterator(coll);\n\t\treturn iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n\t}\n\n\tfunction onlyOnce(fn) {\n\t\treturn function () {\n\t\t\tif (fn === null) throw new Error(\"Callback was already called.\");\n\t\t\tvar callFn = fn;\n\t\t\tfn = null;\n\t\t\tcallFn.apply(this, arguments);\n\t\t};\n\t}\n\n\tfunction _eachOfLimit(limit) {\n\t\treturn function (obj, iteratee, callback) {\n\t\t\tcallback = once(callback || noop);\n\t\t\tif (limit <= 0 || !obj) {\n\t\t\t\treturn callback(null);\n\t\t\t}\n\t\t\tvar nextElem = iterator(obj);\n\t\t\tvar done = false;\n\t\t\tvar running = 0;\n\n\t\t\tfunction iterateeCallback(err, value) {\n\t\t\t\trunning -= 1;\n\t\t\t\tif (err) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t\telse if (value === breakLoop || (done && running <= 0)) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\treturn callback(null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treplenish();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction replenish() {\n\t\t\t\twhile (running < limit && !done) {\n\t\t\t\t\tvar elem = nextElem();\n\t\t\t\t\tif (elem === null) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tif (running <= 0) {\n\t\t\t\t\t\t\tcallback(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\trunning += 1;\n\t\t\t\t\titeratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treplenish();\n\t\t};\n\t}\n\n\t/**\n\t * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name eachOfLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.eachOf]{@link module:Collections.eachOf}\n\t * @alias forEachOfLimit\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each\n\t * item in `coll`. The `key` is the item's key, or index in the case of an\n\t * array.\n\t * Invoked with (item, key, callback).\n\t * @param {Function} [callback] - A callback which is called when all\n\t * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n\t */\n\tfunction eachOfLimit(coll, limit, iteratee, callback) {\n\t\t_eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n\t}\n\n\tfunction doLimit(fn, limit) {\n\t\treturn function (iterable, iteratee, callback) {\n\t\t\treturn fn(iterable, limit, iteratee, callback);\n\t\t};\n\t}\n\n\t// eachOf implementation optimized for array-likes\n\tfunction eachOfArrayLike(coll, iteratee, callback) {\n\t\tcallback = once(callback || noop);\n\t\tvar index = 0,\n\t\t\tcompleted = 0,\n\t\t\tlength = coll.length;\n\t\tif (length === 0) {\n\t\t\tcallback(null);\n\t\t}\n\n\t\tfunction iteratorCallback(err, value) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else if ((++completed === length) || value === breakLoop) {\n\t\t\t\tcallback(null);\n\t\t\t}\n\t\t}\n\n\t\tfor (; index < length; index++) {\n\t\t\titeratee(coll[index], index, onlyOnce(iteratorCallback));\n\t\t}\n\t}\n\n\t// a generic version of eachOf which can handle array, object, and iterator cases.\n\tvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n\t/**\n\t * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n\t * to the iteratee.\n\t *\n\t * @name eachOf\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias forEachOf\n\t * @category Collection\n\t * @see [async.each]{@link module:Collections.each}\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A function to apply to each\n\t * item in `coll`.\n\t * The `key` is the item's key, or index in the case of an array.\n\t * Invoked with (item, key, callback).\n\t * @param {Function} [callback] - A callback which is called when all\n\t * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n\t * @example\n\t *\n\t * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n\t * var configs = {};\n\t *\n\t * async.forEachOf(obj, function (value, key, callback) {\n\t *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n\t *         if (err) return callback(err);\n\t *         try {\n\t *             configs[key] = JSON.parse(data);\n\t *         } catch (e) {\n\t *             return callback(e);\n\t *         }\n\t *         callback();\n\t *     });\n\t * }, function (err) {\n\t *     if (err) console.error(err.message);\n\t *     // configs is now a map of JSON data\n\t *     doSomethingWith(configs);\n\t * });\n\t */\n\tvar eachOf = function (coll, iteratee, callback) {\n\t\tvar eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n\t\teachOfImplementation(coll, wrapAsync(iteratee), callback);\n\t};\n\n\tfunction doParallel(fn) {\n\t\treturn function (obj, iteratee, callback) {\n\t\t\treturn fn(eachOf, obj, wrapAsync(iteratee), callback);\n\t\t};\n\t}\n\n\tfunction _asyncMap(eachfn, arr, iteratee, callback) {\n\t\tcallback = callback || noop;\n\t\tarr = arr || [];\n\t\tvar results = [];\n\t\tvar counter = 0;\n\t\tvar _iteratee = wrapAsync(iteratee);\n\n\t\teachfn(arr, function (value, _, callback) {\n\t\t\tvar index = counter++;\n\t\t\t_iteratee(value, function (err, v) {\n\t\t\t\tresults[index] = v;\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tcallback(err, results);\n\t\t});\n\t}\n\n\t/**\n\t * Produces a new collection of values by mapping each value in `coll` through\n\t * the `iteratee` function. The `iteratee` is called with an item from `coll`\n\t * and a callback for when it has finished processing. Each of these callback\n\t * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n\t * `iteratee` passes an error to its callback, the main `callback` (for the\n\t * `map` function) is immediately called with the error.\n\t *\n\t * Note, that since this function applies the `iteratee` to each item in\n\t * parallel, there is no guarantee that the `iteratee` functions will complete\n\t * in order. However, the results array will be in the same order as the\n\t * original `coll`.\n\t *\n\t * If `map` is passed an Object, the results will be an Array.  The results\n\t * will roughly be in the order of the original Objects' keys (but this can\n\t * vary across JavaScript engines).\n\t *\n\t * @name map\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with the transformed item.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Results is an Array of the\n\t * transformed items from the `coll`. Invoked with (err, results).\n\t * @example\n\t *\n\t * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n\t *     // results is now an array of stats for each file\n\t * });\n\t */\n\tvar map = doParallel(_asyncMap);\n\n\t/**\n\t * Applies the provided arguments to each function in the array, calling\n\t * `callback` after all functions have completed. If you only provide the first\n\t * argument, `fns`, then it will return a function which lets you pass in the\n\t * arguments as if it were a single function call. If more arguments are\n\t * provided, `callback` is required while `args` is still optional.\n\t *\n\t * @name applyEach\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n\t * to all call with the same arguments\n\t * @param {...*} [args] - any number of separate arguments to pass to the\n\t * function.\n\t * @param {Function} [callback] - the final argument should be the callback,\n\t * called when all functions have completed processing.\n\t * @returns {Function} - If only the first argument, `fns`, is provided, it will\n\t * return a function which lets you pass in the arguments as if it were a single\n\t * function call. The signature is `(..args, callback)`. If invoked with any\n\t * arguments, `callback` is required.\n\t * @example\n\t *\n\t * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n\t *\n\t * // partial application example:\n\t * async.each(\n\t *     buckets,\n\t *     async.applyEach([enableSearch, updateSchema]),\n\t *     callback\n\t * );\n\t */\n\tvar applyEach = applyEach$1(map);\n\n\tfunction doParallelLimit(fn) {\n\t\treturn function (obj, limit, iteratee, callback) {\n\t\t\treturn fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);\n\t\t};\n\t}\n\n\t/**\n\t * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n\t *\n\t * @name mapLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.map]{@link module:Collections.map}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with the transformed item.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Results is an array of the\n\t * transformed items from the `coll`. Invoked with (err, results).\n\t */\n\tvar mapLimit = doParallelLimit(_asyncMap);\n\n\t/**\n\t * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n\t *\n\t * @name mapSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.map]{@link module:Collections.map}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with the transformed item.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Results is an array of the\n\t * transformed items from the `coll`. Invoked with (err, results).\n\t */\n\tvar mapSeries = doLimit(mapLimit, 1);\n\n\t/**\n\t * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n\t *\n\t * @name applyEachSeries\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n\t * @category Control Flow\n\t * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n\t * call with the same arguments\n\t * @param {...*} [args] - any number of separate arguments to pass to the\n\t * function.\n\t * @param {Function} [callback] - the final argument should be the callback,\n\t * called when all functions have completed processing.\n\t * @returns {Function} - If only the first argument is provided, it will return\n\t * a function which lets you pass in the arguments as if it were a single\n\t * function call.\n\t */\n\tvar applyEachSeries = applyEach$1(mapSeries);\n\n\t/**\n\t * Creates a continuation function with some arguments already applied.\n\t *\n\t * Useful as a shorthand when combined with other control flow functions. Any\n\t * arguments passed to the returned function are added to the arguments\n\t * originally passed to apply.\n\t *\n\t * @name apply\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {Function} fn - The function you want to eventually apply all\n\t * arguments to. Invokes with (arguments...).\n\t * @param {...*} arguments... - Any number of arguments to automatically apply\n\t * when the continuation is called.\n\t * @returns {Function} the partially-applied function\n\t * @example\n\t *\n\t * // using apply\n\t * async.parallel([\n\t *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n\t *     async.apply(fs.writeFile, 'testfile2', 'test2')\n\t * ]);\n\t *\n\t *\n\t * // the same process without using apply\n\t * async.parallel([\n\t *     function(callback) {\n\t *         fs.writeFile('testfile1', 'test1', callback);\n\t *     },\n\t *     function(callback) {\n\t *         fs.writeFile('testfile2', 'test2', callback);\n\t *     }\n\t * ]);\n\t *\n\t * // It's possible to pass any number of additional arguments when calling the\n\t * // continuation:\n\t *\n\t * node> var fn = async.apply(sys.puts, 'one');\n\t * node> fn('two', 'three');\n\t * one\n\t * two\n\t * three\n\t */\n\tvar apply = function (fn/*, ...args*/) {\n\t\tvar args = slice(arguments, 1);\n\t\treturn function (/*callArgs*/) {\n\t\t\tvar callArgs = slice(arguments);\n\t\t\treturn fn.apply(null, args.concat(callArgs));\n\t\t};\n\t};\n\n\t/**\n\t * A specialized version of `_.forEach` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayEach(array, iteratee) {\n\t\tvar index = -1,\n\t\t\tlength = array == null ? 0 : array.length;\n\n\t\twhile (++index < length) {\n\t\t\tif (iteratee(array[index], index, array) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n\t *\n\t * @private\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseFor(fromRight) {\n\t\treturn function (object, iteratee, keysFunc) {\n\t\t\tvar index = -1,\n\t\t\t\titerable = Object(object),\n\t\t\t\tprops = keysFunc(object),\n\t\t\t\tlength = props.length;\n\n\t\t\twhile (length--) {\n\t\t\t\tvar key = props[fromRight ? length : ++index];\n\t\t\t\tif (iteratee(iterable[key], key, iterable) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t};\n\t}\n\n\t/**\n\t * The base implementation of `baseForOwn` which iterates over `object`\n\t * properties returned by `keysFunc` and invokes `iteratee` for each property.\n\t * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @returns {Object} Returns `object`.\n\t */\n\tvar baseFor = createBaseFor();\n\n\t/**\n\t * The base implementation of `_.forOwn` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseForOwn(object, iteratee) {\n\t\treturn object && baseFor(object, iteratee, keys);\n\t}\n\n\t/**\n\t * The base implementation of `_.findIndex` and `_.findLastIndex` without\n\t * support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @param {number} fromIndex The index to search from.\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n\t\tvar length = array.length,\n\t\t\tindex = fromIndex + (fromRight ? 1 : -1);\n\n\t\twhile ((fromRight ? index-- : ++index < length)) {\n\t\t\tif (predicate(array[index], index, array)) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * The base implementation of `_.isNaN` without support for number objects.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t */\n\tfunction baseIsNaN(value) {\n\t\treturn value !== value;\n\t}\n\n\t/**\n\t * A specialized version of `_.indexOf` which performs strict equality\n\t * comparisons of values, i.e. `===`.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} value The value to search for.\n\t * @param {number} fromIndex The index to search from.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction strictIndexOf(array, value, fromIndex) {\n\t\tvar index = fromIndex - 1,\n\t\t\tlength = array.length;\n\n\t\twhile (++index < length) {\n\t\t\tif (array[index] === value) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} value The value to search for.\n\t * @param {number} fromIndex The index to search from.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction baseIndexOf(array, value, fromIndex) {\n\t\treturn value === value\n\t\t\t? strictIndexOf(array, value, fromIndex)\n\t\t\t: baseFindIndex(array, baseIsNaN, fromIndex);\n\t}\n\n\t/**\n\t * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n\t * their requirements. Each function can optionally depend on other functions\n\t * being completed first, and each function is run as soon as its requirements\n\t * are satisfied.\n\t *\n\t * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n\t * will stop. Further tasks will not execute (so any other functions depending\n\t * on it will not run), and the main `callback` is immediately called with the\n\t * error.\n\t *\n\t * {@link AsyncFunction}s also receive an object containing the results of functions which\n\t * have completed so far as the first argument, if they have dependencies. If a\n\t * task function has no dependencies, it will only be passed a callback.\n\t *\n\t * @name auto\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Object} tasks - An object. Each of its properties is either a\n\t * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n\t * in the array. The object's key of a property serves as the name of the task\n\t * defined by that property, i.e. can be used when specifying requirements for\n\t * other tasks. The function receives one or two arguments:\n\t * * a `results` object, containing the results of the previously executed\n\t *   functions, only passed if the task has any dependencies,\n\t * * a `callback(err, result)` function, which must be called when finished,\n\t *   passing an `error` (which can be `null`) and the result of the function's\n\t *   execution.\n\t * @param {number} [concurrency=Infinity] - An optional `integer` for\n\t * determining the maximum number of tasks that can be run in parallel. By\n\t * default, as many as possible.\n\t * @param {Function} [callback] - An optional callback which is called when all\n\t * the tasks have been completed. It receives the `err` argument if any `tasks`\n\t * pass an error to their callback. Results are always returned; however, if an\n\t * error occurs, no further `tasks` will be performed, and the results object\n\t * will only contain partial results. Invoked with (err, results).\n\t * @returns undefined\n\t * @example\n\t *\n\t * async.auto({\n\t *     // this function will just be passed a callback\n\t *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n\t *     showData: ['readData', function(results, cb) {\n\t *         // results.readData is the file's contents\n\t *         // ...\n\t *     }]\n\t * }, callback);\n\t *\n\t * async.auto({\n\t *     get_data: function(callback) {\n\t *         console.log('in get_data');\n\t *         // async code to get some data\n\t *         callback(null, 'data', 'converted to array');\n\t *     },\n\t *     make_folder: function(callback) {\n\t *         console.log('in make_folder');\n\t *         // async code to create a directory to store a file in\n\t *         // this is run at the same time as getting the data\n\t *         callback(null, 'folder');\n\t *     },\n\t *     write_file: ['get_data', 'make_folder', function(results, callback) {\n\t *         console.log('in write_file', JSON.stringify(results));\n\t *         // once there is some data and the directory exists,\n\t *         // write the data to a file in the directory\n\t *         callback(null, 'filename');\n\t *     }],\n\t *     email_link: ['write_file', function(results, callback) {\n\t *         console.log('in email_link', JSON.stringify(results));\n\t *         // once the file is written let's email a link to it...\n\t *         // results.write_file contains the filename returned by write_file.\n\t *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n\t *     }]\n\t * }, function(err, results) {\n\t *     console.log('err = ', err);\n\t *     console.log('results = ', results);\n\t * });\n\t */\n\tvar auto = function (tasks, concurrency, callback) {\n\t\tif (typeof concurrency === 'function') {\n\t\t\t// concurrency is optional, shift the args.\n\t\t\tcallback = concurrency;\n\t\t\tconcurrency = null;\n\t\t}\n\t\tcallback = once(callback || noop);\n\t\tvar keys$$1 = keys(tasks);\n\t\tvar numTasks = keys$$1.length;\n\t\tif (!numTasks) {\n\t\t\treturn callback(null);\n\t\t}\n\t\tif (!concurrency) {\n\t\t\tconcurrency = numTasks;\n\t\t}\n\n\t\tvar results = {};\n\t\tvar runningTasks = 0;\n\t\tvar hasError = false;\n\n\t\tvar listeners = Object.create(null);\n\n\t\tvar readyTasks = [];\n\n\t\t// for cycle detection:\n\t\tvar readyToCheck = []; // tasks that have been identified as reachable\n\t\t// without the possibility of returning to an ancestor task\n\t\tvar uncheckedDependencies = {};\n\n\t\tbaseForOwn(tasks, function (task, key) {\n\t\t\tif (!isArray(task)) {\n\t\t\t\t// no dependencies\n\t\t\t\tenqueueTask(key, [task]);\n\t\t\t\treadyToCheck.push(key);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar dependencies = task.slice(0, task.length - 1);\n\t\t\tvar remainingDependencies = dependencies.length;\n\t\t\tif (remainingDependencies === 0) {\n\t\t\t\tenqueueTask(key, task);\n\t\t\t\treadyToCheck.push(key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuncheckedDependencies[key] = remainingDependencies;\n\n\t\t\tarrayEach(dependencies, function (dependencyName) {\n\t\t\t\tif (!tasks[dependencyName]) {\n\t\t\t\t\tthrow new Error('async.auto task `' + key +\n\t\t\t\t\t\t'` has a non-existent dependency `' +\n\t\t\t\t\t\tdependencyName + '` in ' +\n\t\t\t\t\t\tdependencies.join(', '));\n\t\t\t\t}\n\t\t\t\taddListener(dependencyName, function () {\n\t\t\t\t\tremainingDependencies--;\n\t\t\t\t\tif (remainingDependencies === 0) {\n\t\t\t\t\t\tenqueueTask(key, task);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tcheckForDeadlocks();\n\t\tprocessQueue();\n\n\t\tfunction enqueueTask(key, task) {\n\t\t\treadyTasks.push(function () {\n\t\t\t\trunTask(key, task);\n\t\t\t});\n\t\t}\n\n\t\tfunction processQueue() {\n\t\t\tif (readyTasks.length === 0 && runningTasks === 0) {\n\t\t\t\treturn callback(null, results);\n\t\t\t}\n\t\t\twhile (readyTasks.length && runningTasks < concurrency) {\n\t\t\t\tvar run = readyTasks.shift();\n\t\t\t\trun();\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addListener(taskName, fn) {\n\t\t\tvar taskListeners = listeners[taskName];\n\t\t\tif (!taskListeners) {\n\t\t\t\ttaskListeners = listeners[taskName] = [];\n\t\t\t}\n\n\t\t\ttaskListeners.push(fn);\n\t\t}\n\n\t\tfunction taskComplete(taskName) {\n\t\t\tvar taskListeners = listeners[taskName] || [];\n\t\t\tarrayEach(taskListeners, function (fn) {\n\t\t\t\tfn();\n\t\t\t});\n\t\t\tprocessQueue();\n\t\t}\n\n\n\t\tfunction runTask(key, task) {\n\t\t\tif (hasError) return;\n\n\t\t\tvar taskCallback = onlyOnce(function (err, result) {\n\t\t\t\trunningTasks--;\n\t\t\t\tif (arguments.length > 2) {\n\t\t\t\t\tresult = slice(arguments, 1);\n\t\t\t\t}\n\t\t\t\tif (err) {\n\t\t\t\t\tvar safeResults = {};\n\t\t\t\t\tbaseForOwn(results, function (val, rkey) {\n\t\t\t\t\t\tsafeResults[rkey] = val;\n\t\t\t\t\t});\n\t\t\t\t\tsafeResults[key] = result;\n\t\t\t\t\thasError = true;\n\t\t\t\t\tlisteners = Object.create(null);\n\n\t\t\t\t\tcallback(err, safeResults);\n\t\t\t\t} else {\n\t\t\t\t\tresults[key] = result;\n\t\t\t\t\ttaskComplete(key);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trunningTasks++;\n\t\t\tvar taskFn = wrapAsync(task[task.length - 1]);\n\t\t\tif (task.length > 1) {\n\t\t\t\ttaskFn(results, taskCallback);\n\t\t\t} else {\n\t\t\t\ttaskFn(taskCallback);\n\t\t\t}\n\t\t}\n\n\t\tfunction checkForDeadlocks() {\n\t\t\t// Kahn's algorithm\n\t\t\t// https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n\t\t\t// http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n\t\t\tvar currentTask;\n\t\t\tvar counter = 0;\n\t\t\twhile (readyToCheck.length) {\n\t\t\t\tcurrentTask = readyToCheck.pop();\n\t\t\t\tcounter++;\n\t\t\t\tarrayEach(getDependents(currentTask), function (dependent) {\n\t\t\t\t\tif (--uncheckedDependencies[dependent] === 0) {\n\t\t\t\t\t\treadyToCheck.push(dependent);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (counter !== numTasks) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'async.auto cannot execute tasks due to a recursive dependency'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfunction getDependents(taskName) {\n\t\t\tvar result = [];\n\t\t\tbaseForOwn(tasks, function (task, key) {\n\t\t\t\tif (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n\t\t\t\t\tresult.push(key);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t}\n\t};\n\n\t/**\n\t * A specialized version of `_.map` for arrays without support for iteratee\n\t * shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the new mapped array.\n\t */\n\tfunction arrayMap(array, iteratee) {\n\t\tvar index = -1,\n\t\t\tlength = array == null ? 0 : array.length,\n\t\t\tresult = Array(length);\n\n\t\twhile (++index < length) {\n\t\t\tresult[index] = iteratee(array[index], index, array);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar symbolTag = '[object Symbol]';\n\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol(value) {\n\t\treturn typeof value == 'symbol' ||\n\t\t\t(isObjectLike(value) && baseGetTag(value) == symbolTag);\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY = 1 / 0;\n\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\n\tvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n\t/**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t\t// Exit early for strings to avoid a performance hit in some environments.\n\t\tif (typeof value == 'string') {\n\t\t\treturn value;\n\t\t}\n\t\tif (isArray(value)) {\n\t\t\t// Recursively convert values (susceptible to call stack limits).\n\t\t\treturn arrayMap(value, baseToString) + '';\n\t\t}\n\t\tif (isSymbol(value)) {\n\t\t\treturn symbolToString ? symbolToString.call(value) : '';\n\t\t}\n\t\tvar result = (value + '');\n\t\treturn (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t}\n\n\t/**\n\t * The base implementation of `_.slice` without an iteratee call guard.\n\t *\n\t * @private\n\t * @param {Array} array The array to slice.\n\t * @param {number} [start=0] The start position.\n\t * @param {number} [end=array.length] The end position.\n\t * @returns {Array} Returns the slice of `array`.\n\t */\n\tfunction baseSlice(array, start, end) {\n\t\tvar index = -1,\n\t\t\tlength = array.length;\n\n\t\tif (start < 0) {\n\t\t\tstart = -start > length ? 0 : (length + start);\n\t\t}\n\t\tend = end > length ? length : end;\n\t\tif (end < 0) {\n\t\t\tend += length;\n\t\t}\n\t\tlength = start > end ? 0 : ((end - start) >>> 0);\n\t\tstart >>>= 0;\n\n\t\tvar result = Array(length);\n\t\twhile (++index < length) {\n\t\t\tresult[index] = array[index + start];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Casts `array` to a slice if it's needed.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {number} start The start position.\n\t * @param {number} [end=array.length] The end position.\n\t * @returns {Array} Returns the cast slice.\n\t */\n\tfunction castSlice(array, start, end) {\n\t\tvar length = array.length;\n\t\tend = end === undefined ? length : end;\n\t\treturn (!start && end >= length) ? array : baseSlice(array, start, end);\n\t}\n\n\t/**\n\t * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n\t * that is not found in the character symbols.\n\t *\n\t * @private\n\t * @param {Array} strSymbols The string symbols to inspect.\n\t * @param {Array} chrSymbols The character symbols to find.\n\t * @returns {number} Returns the index of the last unmatched string symbol.\n\t */\n\tfunction charsEndIndex(strSymbols, chrSymbols) {\n\t\tvar index = strSymbols.length;\n\n\t\twhile (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }\n\t\treturn index;\n\t}\n\n\t/**\n\t * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n\t * that is not found in the character symbols.\n\t *\n\t * @private\n\t * @param {Array} strSymbols The string symbols to inspect.\n\t * @param {Array} chrSymbols The character symbols to find.\n\t * @returns {number} Returns the index of the first unmatched string symbol.\n\t */\n\tfunction charsStartIndex(strSymbols, chrSymbols) {\n\t\tvar index = -1,\n\t\t\tlength = strSymbols.length;\n\n\t\twhile (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }\n\t\treturn index;\n\t}\n\n\t/**\n\t * Converts an ASCII `string` to an array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the converted array.\n\t */\n\tfunction asciiToArray(string) {\n\t\treturn string.split('');\n\t}\n\n\t/** Used to compose unicode character classes. */\n\tvar rsAstralRange = '\\\\ud800-\\\\udfff';\n\tvar rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\n\tvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\n\tvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n\t/** Used to compose unicode capture groups. */\n\tvar rsZWJ = '\\\\u200d';\n\n\t/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\tvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n\t/**\n\t * Checks if `string` contains Unicode symbols.\n\t *\n\t * @private\n\t * @param {string} string The string to inspect.\n\t * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n\t */\n\tfunction hasUnicode(string) {\n\t\treturn reHasUnicode.test(string);\n\t}\n\n\t/** Used to compose unicode character classes. */\n\tvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\n\tvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\n\tvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20f0';\n\tvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n\t/** Used to compose unicode capture groups. */\n\tvar rsAstral = '[' + rsAstralRange$1 + ']';\n\tvar rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';\n\tvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\n\tvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\n\tvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\n\tvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\n\tvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\n\tvar rsZWJ$1 = '\\\\u200d';\n\n\t/** Used to compose unicode regexes. */\n\tvar reOptMod = rsModifier + '?';\n\tvar rsOptVar = '[' + rsVarRange$1 + ']?';\n\tvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\n\tvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\n\tvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n\t/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\tvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n\t/**\n\t * Converts a Unicode `string` to an array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the converted array.\n\t */\n\tfunction unicodeToArray(string) {\n\t\treturn string.match(reUnicode) || [];\n\t}\n\n\t/**\n\t * Converts `string` to an array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the converted array.\n\t */\n\tfunction stringToArray(string) {\n\t\treturn hasUnicode(string)\n\t\t\t? unicodeToArray(string)\n\t\t\t: asciiToArray(string);\n\t}\n\n\t/**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */\n\tfunction toString(value) {\n\t\treturn value == null ? '' : baseToString(value);\n\t}\n\n\t/** Used to match leading and trailing whitespace. */\n\tvar reTrim = /^\\s+|\\s+$/g;\n\n\t/**\n\t * Removes leading and trailing whitespace or specified characters from `string`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category String\n\t * @param {string} [string=''] The string to trim.\n\t * @param {string} [chars=whitespace] The characters to trim.\n\t * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n\t * @returns {string} Returns the trimmed string.\n\t * @example\n\t *\n\t * _.trim('  abc  ');\n\t * // => 'abc'\n\t *\n\t * _.trim('-_-abc-_-', '_-');\n\t * // => 'abc'\n\t *\n\t * _.map(['  foo  ', '  bar  '], _.trim);\n\t * // => ['foo', 'bar']\n\t */\n\tfunction trim(string, chars, guard) {\n\t\tstring = toString(string);\n\t\tif (string && (guard || chars === undefined)) {\n\t\t\treturn string.replace(reTrim, '');\n\t\t}\n\t\tif (!string || !(chars = baseToString(chars))) {\n\t\t\treturn string;\n\t\t}\n\t\tvar strSymbols = stringToArray(string),\n\t\t\tchrSymbols = stringToArray(chars),\n\t\t\tstart = charsStartIndex(strSymbols, chrSymbols),\n\t\t\tend = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n\t\treturn castSlice(strSymbols, start, end).join('');\n\t}\n\n\tvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n\tvar FN_ARG_SPLIT = /,/;\n\tvar FN_ARG = /(=.+)?(\\s*)$/;\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\n\tfunction parseParams(func) {\n\t\tfunc = func.toString().replace(STRIP_COMMENTS, '');\n\t\tfunc = func.match(FN_ARGS)[2].replace(' ', '');\n\t\tfunc = func ? func.split(FN_ARG_SPLIT) : [];\n\t\tfunc = func.map(function (arg) {\n\t\t\treturn trim(arg.replace(FN_ARG, ''));\n\t\t});\n\t\treturn func;\n\t}\n\n\t/**\n\t * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n\t * tasks are specified as parameters to the function, after the usual callback\n\t * parameter, with the parameter names matching the names of the tasks it\n\t * depends on. This can provide even more readable task graphs which can be\n\t * easier to maintain.\n\t *\n\t * If a final callback is specified, the task results are similarly injected,\n\t * specified as named parameters after the initial error parameter.\n\t *\n\t * The autoInject function is purely syntactic sugar and its semantics are\n\t * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n\t *\n\t * @name autoInject\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.auto]{@link module:ControlFlow.auto}\n\t * @category Control Flow\n\t * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n\t * the form 'func([dependencies...], callback). The object's key of a property\n\t * serves as the name of the task defined by that property, i.e. can be used\n\t * when specifying requirements for other tasks.\n\t * * The `callback` parameter is a `callback(err, result)` which must be called\n\t *   when finished, passing an `error` (which can be `null`) and the result of\n\t *   the function's execution. The remaining parameters name other tasks on\n\t *   which the task is dependent, and the results from those tasks are the\n\t *   arguments of those parameters.\n\t * @param {Function} [callback] - An optional callback which is called when all\n\t * the tasks have been completed. It receives the `err` argument if any `tasks`\n\t * pass an error to their callback, and a `results` object with any completed\n\t * task results, similar to `auto`.\n\t * @example\n\t *\n\t * //  The example from `auto` can be rewritten as follows:\n\t * async.autoInject({\n\t *     get_data: function(callback) {\n\t *         // async code to get some data\n\t *         callback(null, 'data', 'converted to array');\n\t *     },\n\t *     make_folder: function(callback) {\n\t *         // async code to create a directory to store a file in\n\t *         // this is run at the same time as getting the data\n\t *         callback(null, 'folder');\n\t *     },\n\t *     write_file: function(get_data, make_folder, callback) {\n\t *         // once there is some data and the directory exists,\n\t *         // write the data to a file in the directory\n\t *         callback(null, 'filename');\n\t *     },\n\t *     email_link: function(write_file, callback) {\n\t *         // once the file is written let's email a link to it...\n\t *         // write_file contains the filename returned by write_file.\n\t *         callback(null, {'file':write_file, 'email':'user@example.com'});\n\t *     }\n\t * }, function(err, results) {\n\t *     console.log('err = ', err);\n\t *     console.log('email_link = ', results.email_link);\n\t * });\n\t *\n\t * // If you are using a JS minifier that mangles parameter names, `autoInject`\n\t * // will not work with plain functions, since the parameter names will be\n\t * // collapsed to a single letter identifier.  To work around this, you can\n\t * // explicitly specify the names of the parameters your task function needs\n\t * // in an array, similar to Angular.js dependency injection.\n\t *\n\t * // This still has an advantage over plain `auto`, since the results a task\n\t * // depends on are still spread into arguments.\n\t * async.autoInject({\n\t *     //...\n\t *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n\t *         callback(null, 'filename');\n\t *     }],\n\t *     email_link: ['write_file', function(write_file, callback) {\n\t *         callback(null, {'file':write_file, 'email':'user@example.com'});\n\t *     }]\n\t *     //...\n\t * }, function(err, results) {\n\t *     console.log('err = ', err);\n\t *     console.log('email_link = ', results.email_link);\n\t * });\n\t */\n\tfunction autoInject(tasks, callback) {\n\t\tvar newTasks = {};\n\n\t\tbaseForOwn(tasks, function (taskFn, key) {\n\t\t\tvar params;\n\t\t\tvar fnIsAsync = isAsync(taskFn);\n\t\t\tvar hasNoDeps =\n\t\t\t\t(!fnIsAsync && taskFn.length === 1) ||\n\t\t\t\t(fnIsAsync && taskFn.length === 0);\n\n\t\t\tif (isArray(taskFn)) {\n\t\t\t\tparams = taskFn.slice(0, -1);\n\t\t\t\ttaskFn = taskFn[taskFn.length - 1];\n\n\t\t\t\tnewTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n\t\t\t} else if (hasNoDeps) {\n\t\t\t\t// no dependencies, use the function as-is\n\t\t\t\tnewTasks[key] = taskFn;\n\t\t\t} else {\n\t\t\t\tparams = parseParams(taskFn);\n\t\t\t\tif (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n\t\t\t\t\tthrow new Error(\"autoInject task functions require explicit parameters.\");\n\t\t\t\t}\n\n\t\t\t\t// remove callback param\n\t\t\t\tif (!fnIsAsync) params.pop();\n\n\t\t\t\tnewTasks[key] = params.concat(newTask);\n\t\t\t}\n\n\t\t\tfunction newTask(results, taskCb) {\n\t\t\t\tvar newArgs = arrayMap(params, function (name) {\n\t\t\t\t\treturn results[name];\n\t\t\t\t});\n\t\t\t\tnewArgs.push(taskCb);\n\t\t\t\twrapAsync(taskFn).apply(null, newArgs);\n\t\t\t}\n\t\t});\n\n\t\tauto(newTasks, callback);\n\t}\n\n\t// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n\t// used for queues. This implementation assumes that the node provided by the user can be modified\n\t// to adjust the next and last properties. We implement only the minimal functionality\n\t// for queue support.\n\tfunction DLL() {\n\t\tthis.head = this.tail = null;\n\t\tthis.length = 0;\n\t}\n\n\tfunction setInitial(dll, node) {\n\t\tdll.length = 1;\n\t\tdll.head = dll.tail = node;\n\t}\n\n\tDLL.prototype.removeLink = function (node) {\n\t\tif (node.prev) node.prev.next = node.next;\n\t\telse this.head = node.next;\n\t\tif (node.next) node.next.prev = node.prev;\n\t\telse this.tail = node.prev;\n\n\t\tnode.prev = node.next = null;\n\t\tthis.length -= 1;\n\t\treturn node;\n\t};\n\n\tDLL.prototype.empty = function () {\n\t\twhile (this.head) this.shift();\n\t\treturn this;\n\t};\n\n\tDLL.prototype.insertAfter = function (node, newNode) {\n\t\tnewNode.prev = node;\n\t\tnewNode.next = node.next;\n\t\tif (node.next) node.next.prev = newNode;\n\t\telse this.tail = newNode;\n\t\tnode.next = newNode;\n\t\tthis.length += 1;\n\t};\n\n\tDLL.prototype.insertBefore = function (node, newNode) {\n\t\tnewNode.prev = node.prev;\n\t\tnewNode.next = node;\n\t\tif (node.prev) node.prev.next = newNode;\n\t\telse this.head = newNode;\n\t\tnode.prev = newNode;\n\t\tthis.length += 1;\n\t};\n\n\tDLL.prototype.unshift = function (node) {\n\t\tif (this.head) this.insertBefore(this.head, node);\n\t\telse setInitial(this, node);\n\t};\n\n\tDLL.prototype.push = function (node) {\n\t\tif (this.tail) this.insertAfter(this.tail, node);\n\t\telse setInitial(this, node);\n\t};\n\n\tDLL.prototype.shift = function () {\n\t\treturn this.head && this.removeLink(this.head);\n\t};\n\n\tDLL.prototype.pop = function () {\n\t\treturn this.tail && this.removeLink(this.tail);\n\t};\n\n\tDLL.prototype.toArray = function () {\n\t\tvar arr = Array(this.length);\n\t\tvar curr = this.head;\n\t\tfor (var idx = 0; idx < this.length; idx++) {\n\t\t\tarr[idx] = curr.data;\n\t\t\tcurr = curr.next;\n\t\t}\n\t\treturn arr;\n\t};\n\n\tDLL.prototype.remove = function (testFn) {\n\t\tvar curr = this.head;\n\t\twhile (!!curr) {\n\t\t\tvar next = curr.next;\n\t\t\tif (testFn(curr)) {\n\t\t\t\tthis.removeLink(curr);\n\t\t\t}\n\t\t\tcurr = next;\n\t\t}\n\t\treturn this;\n\t};\n\n\tfunction queue(worker, concurrency, payload) {\n\t\tif (concurrency == null) {\n\t\t\tconcurrency = 1;\n\t\t}\n\t\telse if (concurrency === 0) {\n\t\t\tthrow new Error('Concurrency must not be zero');\n\t\t}\n\n\t\tvar _worker = wrapAsync(worker);\n\t\tvar numRunning = 0;\n\t\tvar workersList = [];\n\n\t\tfunction _insert(data, insertAtFront, callback) {\n\t\t\tif (callback != null && typeof callback !== 'function') {\n\t\t\t\tthrow new Error('task callback must be a function');\n\t\t\t}\n\t\t\tq.started = true;\n\t\t\tif (!isArray(data)) {\n\t\t\t\tdata = [data];\n\t\t\t}\n\t\t\tif (data.length === 0 && q.idle()) {\n\t\t\t\t// call drain immediately if there are no tasks\n\t\t\t\treturn setImmediate$1(function () {\n\t\t\t\t\tq.drain();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = data.length; i < l; i++) {\n\t\t\t\tvar item = {\n\t\t\t\t\tdata: data[i],\n\t\t\t\t\tcallback: callback || noop\n\t\t\t\t};\n\n\t\t\t\tif (insertAtFront) {\n\t\t\t\t\tq._tasks.unshift(item);\n\t\t\t\t} else {\n\t\t\t\t\tq._tasks.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetImmediate$1(q.process);\n\t\t}\n\n\t\tfunction _next(tasks) {\n\t\t\treturn function (err) {\n\t\t\t\tnumRunning -= 1;\n\n\t\t\t\tfor (var i = 0, l = tasks.length; i < l; i++) {\n\t\t\t\t\tvar task = tasks[i];\n\t\t\t\t\tvar index = baseIndexOf(workersList, task, 0);\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tworkersList.splice(index);\n\t\t\t\t\t}\n\n\t\t\t\t\ttask.callback.apply(task, arguments);\n\n\t\t\t\t\tif (err != null) {\n\t\t\t\t\t\tq.error(err, task.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (numRunning <= (q.concurrency - q.buffer)) {\n\t\t\t\t\tq.unsaturated();\n\t\t\t\t}\n\n\t\t\t\tif (q.idle()) {\n\t\t\t\t\tq.drain();\n\t\t\t\t}\n\t\t\t\tq.process();\n\t\t\t};\n\t\t}\n\n\t\tvar isProcessing = false;\n\t\tvar q = {\n\t\t\t_tasks: new DLL(),\n\t\t\tconcurrency: concurrency,\n\t\t\tpayload: payload,\n\t\t\tsaturated: noop,\n\t\t\tunsaturated: noop,\n\t\t\tbuffer: concurrency / 4,\n\t\t\tempty: noop,\n\t\t\tdrain: noop,\n\t\t\terror: noop,\n\t\t\tstarted: false,\n\t\t\tpaused: false,\n\t\t\tpush: function (data, callback) {\n\t\t\t\t_insert(data, false, callback);\n\t\t\t},\n\t\t\tkill: function () {\n\t\t\t\tq.drain = noop;\n\t\t\t\tq._tasks.empty();\n\t\t\t},\n\t\t\tunshift: function (data, callback) {\n\t\t\t\t_insert(data, true, callback);\n\t\t\t},\n\t\t\tremove: function (testFn) {\n\t\t\t\tq._tasks.remove(testFn);\n\t\t\t},\n\t\t\tprocess: function () {\n\t\t\t\t// Avoid trying to start too many processing operations. This can occur\n\t\t\t\t// when callbacks resolve synchronously (#1267).\n\t\t\t\tif (isProcessing) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tisProcessing = true;\n\t\t\t\twhile (!q.paused && numRunning < q.concurrency && q._tasks.length) {\n\t\t\t\t\tvar tasks = [], data = [];\n\t\t\t\t\tvar l = q._tasks.length;\n\t\t\t\t\tif (q.payload) l = Math.min(l, q.payload);\n\t\t\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\t\t\tvar node = q._tasks.shift();\n\t\t\t\t\t\ttasks.push(node);\n\t\t\t\t\t\tdata.push(node.data);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumRunning += 1;\n\t\t\t\t\tworkersList.push(tasks[0]);\n\n\t\t\t\t\tif (q._tasks.length === 0) {\n\t\t\t\t\t\tq.empty();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (numRunning === q.concurrency) {\n\t\t\t\t\t\tq.saturated();\n\t\t\t\t\t}\n\n\t\t\t\t\tvar cb = onlyOnce(_next(tasks));\n\t\t\t\t\t_worker(data, cb);\n\t\t\t\t}\n\t\t\t\tisProcessing = false;\n\t\t\t},\n\t\t\tlength: function () {\n\t\t\t\treturn q._tasks.length;\n\t\t\t},\n\t\t\trunning: function () {\n\t\t\t\treturn numRunning;\n\t\t\t},\n\t\t\tworkersList: function () {\n\t\t\t\treturn workersList;\n\t\t\t},\n\t\t\tidle: function () {\n\t\t\t\treturn q._tasks.length + numRunning === 0;\n\t\t\t},\n\t\t\tpause: function () {\n\t\t\t\tq.paused = true;\n\t\t\t},\n\t\t\tresume: function () {\n\t\t\t\tif (q.paused === false) { return; }\n\t\t\t\tq.paused = false;\n\t\t\t\tsetImmediate$1(q.process);\n\t\t\t}\n\t\t};\n\t\treturn q;\n\t}\n\n\t/**\n\t * A cargo of tasks for the worker function to complete. Cargo inherits all of\n\t * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n\t * @typedef {Object} CargoObject\n\t * @memberOf module:ControlFlow\n\t * @property {Function} length - A function returning the number of items\n\t * waiting to be processed. Invoke like `cargo.length()`.\n\t * @property {number} payload - An `integer` for determining how many tasks\n\t * should be process per round. This property can be changed after a `cargo` is\n\t * created to alter the payload on-the-fly.\n\t * @property {Function} push - Adds `task` to the `queue`. The callback is\n\t * called once the `worker` has finished processing the task. Instead of a\n\t * single task, an array of `tasks` can be submitted. The respective callback is\n\t * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n\t * @property {Function} saturated - A callback that is called when the\n\t * `queue.length()` hits the concurrency and further tasks will be queued.\n\t * @property {Function} empty - A callback that is called when the last item\n\t * from the `queue` is given to a `worker`.\n\t * @property {Function} drain - A callback that is called when the last item\n\t * from the `queue` has returned from the `worker`.\n\t * @property {Function} idle - a function returning false if there are items\n\t * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n\t * @property {Function} pause - a function that pauses the processing of tasks\n\t * until `resume()` is called. Invoke like `cargo.pause()`.\n\t * @property {Function} resume - a function that resumes the processing of\n\t * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n\t * @property {Function} kill - a function that removes the `drain` callback and\n\t * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n\t */\n\n\t/**\n\t * Creates a `cargo` object with the specified payload. Tasks added to the\n\t * cargo will be processed altogether (up to the `payload` limit). If the\n\t * `worker` is in progress, the task is queued until it becomes available. Once\n\t * the `worker` has completed some tasks, each callback of those tasks is\n\t * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n\t * for how `cargo` and `queue` work.\n\t *\n\t * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n\t * at a time, cargo passes an array of tasks to a single worker, repeating\n\t * when the worker is finished.\n\t *\n\t * @name cargo\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.queue]{@link module:ControlFlow.queue}\n\t * @category Control Flow\n\t * @param {AsyncFunction} worker - An asynchronous function for processing an array\n\t * of queued tasks. Invoked with `(tasks, callback)`.\n\t * @param {number} [payload=Infinity] - An optional `integer` for determining\n\t * how many tasks should be processed per round; if omitted, the default is\n\t * unlimited.\n\t * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n\t * attached as certain properties to listen for specific events during the\n\t * lifecycle of the cargo and inner queue.\n\t * @example\n\t *\n\t * // create a cargo object with payload 2\n\t * var cargo = async.cargo(function(tasks, callback) {\n\t *     for (var i=0; i<tasks.length; i++) {\n\t *         console.log('hello ' + tasks[i].name);\n\t *     }\n\t *     callback();\n\t * }, 2);\n\t *\n\t * // add some items\n\t * cargo.push({name: 'foo'}, function(err) {\n\t *     console.log('finished processing foo');\n\t * });\n\t * cargo.push({name: 'bar'}, function(err) {\n\t *     console.log('finished processing bar');\n\t * });\n\t * cargo.push({name: 'baz'}, function(err) {\n\t *     console.log('finished processing baz');\n\t * });\n\t */\n\tfunction cargo(worker, payload) {\n\t\treturn queue(worker, 1, payload);\n\t}\n\n\t/**\n\t * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n\t *\n\t * @name eachOfSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.eachOf]{@link module:Collections.eachOf}\n\t * @alias forEachOfSeries\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * Invoked with (item, key, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Invoked with (err).\n\t */\n\tvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n\t/**\n\t * Reduces `coll` into a single value using an async `iteratee` to return each\n\t * successive step. `memo` is the initial state of the reduction. This function\n\t * only operates in series.\n\t *\n\t * For performance reasons, it may make sense to split a call to this function\n\t * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n\t * results. This function is for situations where each step in the reduction\n\t * needs to be async; if you can get the data before reducing it, then it's\n\t * probably a good idea to do so.\n\t *\n\t * @name reduce\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias inject\n\t * @alias foldl\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {*} memo - The initial state of the reduction.\n\t * @param {AsyncFunction} iteratee - A function applied to each item in the\n\t * array to produce the next step in the reduction.\n\t * The `iteratee` should complete with the next state of the reduction.\n\t * If the iteratee complete with an error, the reduction is stopped and the\n\t * main `callback` is immediately called with the error.\n\t * Invoked with (memo, item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Result is the reduced value. Invoked with\n\t * (err, result).\n\t * @example\n\t *\n\t * async.reduce([1,2,3], 0, function(memo, item, callback) {\n\t *     // pointless async:\n\t *     process.nextTick(function() {\n\t *         callback(null, memo + item)\n\t *     });\n\t * }, function(err, result) {\n\t *     // result is now equal to the last value of memo, which is 6\n\t * });\n\t */\n\tfunction reduce(coll, memo, iteratee, callback) {\n\t\tcallback = once(callback || noop);\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\teachOfSeries(coll, function (x, i, callback) {\n\t\t\t_iteratee(memo, x, function (err, v) {\n\t\t\t\tmemo = v;\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tcallback(err, memo);\n\t\t});\n\t}\n\n\t/**\n\t * Version of the compose function that is more natural to read. Each function\n\t * consumes the return value of the previous function. It is the equivalent of\n\t * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n\t *\n\t * Each function is executed with the `this` binding of the composed function.\n\t *\n\t * @name seq\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.compose]{@link module:ControlFlow.compose}\n\t * @category Control Flow\n\t * @param {...AsyncFunction} functions - the asynchronous functions to compose\n\t * @returns {Function} a function that composes the `functions` in order\n\t * @example\n\t *\n\t * // Requires lodash (or underscore), express3 and dresende's orm2.\n\t * // Part of an app, that fetches cats of the logged user.\n\t * // This example uses `seq` function to avoid overnesting and error\n\t * // handling clutter.\n\t * app.get('/cats', function(request, response) {\n\t *     var User = request.models.User;\n\t *     async.seq(\n\t *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n\t *         function(user, fn) {\n\t *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n\t *         }\n\t *     )(req.session.user_id, function (err, cats) {\n\t *         if (err) {\n\t *             console.error(err);\n\t *             response.json({ status: 'error', message: err.message });\n\t *         } else {\n\t *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n\t *         }\n\t *     });\n\t * });\n\t */\n\tfunction seq(/*...functions*/) {\n\t\tvar _functions = arrayMap(arguments, wrapAsync);\n\t\treturn function (/*...args*/) {\n\t\t\tvar args = slice(arguments);\n\t\t\tvar that = this;\n\n\t\t\tvar cb = args[args.length - 1];\n\t\t\tif (typeof cb == 'function') {\n\t\t\t\targs.pop();\n\t\t\t} else {\n\t\t\t\tcb = noop;\n\t\t\t}\n\n\t\t\treduce(_functions, args, function (newargs, fn, cb) {\n\t\t\t\tfn.apply(that, newargs.concat(function (err/*, ...nextargs*/) {\n\t\t\t\t\tvar nextargs = slice(arguments, 1);\n\t\t\t\t\tcb(err, nextargs);\n\t\t\t\t}));\n\t\t\t},\n\t\t\t\tfunction (err, results) {\n\t\t\t\t\tcb.apply(that, [err].concat(results));\n\t\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Creates a function which is a composition of the passed asynchronous\n\t * functions. Each function consumes the return value of the function that\n\t * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n\t * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n\t *\n\t * Each function is executed with the `this` binding of the composed function.\n\t *\n\t * @name compose\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {...AsyncFunction} functions - the asynchronous functions to compose\n\t * @returns {Function} an asynchronous function that is the composed\n\t * asynchronous `functions`\n\t * @example\n\t *\n\t * function add1(n, callback) {\n\t *     setTimeout(function () {\n\t *         callback(null, n + 1);\n\t *     }, 10);\n\t * }\n\t *\n\t * function mul3(n, callback) {\n\t *     setTimeout(function () {\n\t *         callback(null, n * 3);\n\t *     }, 10);\n\t * }\n\t *\n\t * var add1mul3 = async.compose(mul3, add1);\n\t * add1mul3(4, function (err, result) {\n\t *     // result now equals 15\n\t * });\n\t */\n\tvar compose = function (/*...args*/) {\n\t\treturn seq.apply(null, slice(arguments).reverse());\n\t};\n\n\tfunction concat$1(eachfn, arr, fn, callback) {\n\t\tvar result = [];\n\t\teachfn(arr, function (x, index, cb) {\n\t\t\tfn(x, function (err, y) {\n\t\t\t\tresult = result.concat(y || []);\n\t\t\t\tcb(err);\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tcallback(err, result);\n\t\t});\n\t}\n\n\t/**\n\t * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n\t * the concatenated list. The `iteratee`s are called in parallel, and the\n\t * results are concatenated as they return. There is no guarantee that the\n\t * results array will be returned in the original order of `coll` passed to the\n\t * `iteratee` function.\n\t *\n\t * @name concat\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n\t * which should use an array as its result. Invoked with (item, callback).\n\t * @param {Function} [callback(err)] - A callback which is called after all the\n\t * `iteratee` functions have finished, or an error occurs. Results is an array\n\t * containing the concatenated results of the `iteratee` function. Invoked with\n\t * (err, results).\n\t * @example\n\t *\n\t * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n\t *     // files is now a list of filenames that exist in the 3 directories\n\t * });\n\t */\n\tvar concat = doParallel(concat$1);\n\n\tfunction doSeries(fn) {\n\t\treturn function (obj, iteratee, callback) {\n\t\t\treturn fn(eachOfSeries, obj, wrapAsync(iteratee), callback);\n\t\t};\n\t}\n\n\t/**\n\t * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n\t *\n\t * @name concatSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.concat]{@link module:Collections.concat}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n\t * The iteratee should complete with an array an array of results.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback(err)] - A callback which is called after all the\n\t * `iteratee` functions have finished, or an error occurs. Results is an array\n\t * containing the concatenated results of the `iteratee` function. Invoked with\n\t * (err, results).\n\t */\n\tvar concatSeries = doSeries(concat$1);\n\n\t/**\n\t * Returns a function that when called, calls-back with the values provided.\n\t * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n\t * [`auto`]{@link module:ControlFlow.auto}.\n\t *\n\t * @name constant\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {...*} arguments... - Any number of arguments to automatically invoke\n\t * callback with.\n\t * @returns {AsyncFunction} Returns a function that when invoked, automatically\n\t * invokes the callback with the previous given arguments.\n\t * @example\n\t *\n\t * async.waterfall([\n\t *     async.constant(42),\n\t *     function (value, next) {\n\t *         // value === 42\n\t *     },\n\t *     //...\n\t * ], callback);\n\t *\n\t * async.waterfall([\n\t *     async.constant(filename, \"utf8\"),\n\t *     fs.readFile,\n\t *     function (fileData, next) {\n\t *         //...\n\t *     }\n\t *     //...\n\t * ], callback);\n\t *\n\t * async.auto({\n\t *     hostname: async.constant(\"https://server.net/\"),\n\t *     port: findFreePort,\n\t *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n\t *         startServer(options, cb);\n\t *     }],\n\t *     //...\n\t * }, callback);\n\t */\n\tvar constant = function (/*...values*/) {\n\t\tvar values = slice(arguments);\n\t\tvar args = [null].concat(values);\n\t\treturn function (/*...ignoredArgs, callback*/) {\n\t\t\tvar callback = arguments[arguments.length - 1];\n\t\t\treturn callback.apply(this, args);\n\t\t};\n\t};\n\n\t/**\n\t * This method returns the first argument it receives.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Util\n\t * @param {*} value Any value.\n\t * @returns {*} Returns `value`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t *\n\t * console.log(_.identity(object) === object);\n\t * // => true\n\t */\n\tfunction identity(value) {\n\t\treturn value;\n\t}\n\n\tfunction _createTester(check, getResult) {\n\t\treturn function (eachfn, arr, iteratee, cb) {\n\t\t\tcb = cb || noop;\n\t\t\tvar testPassed = false;\n\t\t\tvar testResult;\n\t\t\teachfn(arr, function (value, _, callback) {\n\t\t\t\titeratee(value, function (err, result) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t} else if (check(result) && !testResult) {\n\t\t\t\t\t\ttestPassed = true;\n\t\t\t\t\t\ttestResult = getResult(true, value);\n\t\t\t\t\t\tcallback(null, breakLoop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcb(err);\n\t\t\t\t} else {\n\t\t\t\t\tcb(null, testPassed ? testResult : getResult(false));\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\n\tfunction _findGetResult(v, x) {\n\t\treturn x;\n\t}\n\n\t/**\n\t * Returns the first value in `coll` that passes an async truth test. The\n\t * `iteratee` is applied in parallel, meaning the first iteratee to return\n\t * `true` will fire the detect `callback` with that result. That means the\n\t * result might not be the first item in the original `coll` (in terms of order)\n\t * that passes the test.\n\t\n\t * If order within the original `coll` is important, then look at\n\t * [`detectSeries`]{@link module:Collections.detectSeries}.\n\t *\n\t * @name detect\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias find\n\t * @category Collections\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n\t * The iteratee must complete with a boolean value as its result.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called as soon as any\n\t * iteratee returns `true`, or after all the `iteratee` functions have finished.\n\t * Result will be the first item in the array that passes the truth test\n\t * (iteratee) or the value `undefined` if none passed. Invoked with\n\t * (err, result).\n\t * @example\n\t *\n\t * async.detect(['file1','file2','file3'], function(filePath, callback) {\n\t *     fs.access(filePath, function(err) {\n\t *         callback(null, !err)\n\t *     });\n\t * }, function(err, result) {\n\t *     // result now equals the first file in the list that exists\n\t * });\n\t */\n\tvar detect = doParallel(_createTester(identity, _findGetResult));\n\n\t/**\n\t * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name detectLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.detect]{@link module:Collections.detect}\n\t * @alias findLimit\n\t * @category Collections\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n\t * The iteratee must complete with a boolean value as its result.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called as soon as any\n\t * iteratee returns `true`, or after all the `iteratee` functions have finished.\n\t * Result will be the first item in the array that passes the truth test\n\t * (iteratee) or the value `undefined` if none passed. Invoked with\n\t * (err, result).\n\t */\n\tvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n\t/**\n\t * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n\t *\n\t * @name detectSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.detect]{@link module:Collections.detect}\n\t * @alias findSeries\n\t * @category Collections\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n\t * The iteratee must complete with a boolean value as its result.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called as soon as any\n\t * iteratee returns `true`, or after all the `iteratee` functions have finished.\n\t * Result will be the first item in the array that passes the truth test\n\t * (iteratee) or the value `undefined` if none passed. Invoked with\n\t * (err, result).\n\t */\n\tvar detectSeries = doLimit(detectLimit, 1);\n\n\tfunction consoleFunc(name) {\n\t\treturn function (fn/*, ...args*/) {\n\t\t\tvar args = slice(arguments, 1);\n\t\t\targs.push(function (err/*, ...args*/) {\n\t\t\t\tvar args = slice(arguments, 1);\n\t\t\t\tif (typeof console === 'object') {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (console.error) {\n\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (console[name]) {\n\t\t\t\t\t\tarrayEach(args, function (x) {\n\t\t\t\t\t\t\tconsole[name](x);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twrapAsync(fn).apply(null, args);\n\t\t};\n\t}\n\n\t/**\n\t * Logs the result of an [`async` function]{@link AsyncFunction} to the\n\t * `console` using `console.dir` to display the properties of the resulting object.\n\t * Only works in Node.js or in browsers that support `console.dir` and\n\t * `console.error` (such as FF and Chrome).\n\t * If multiple arguments are returned from the async function,\n\t * `console.dir` is called on each argument in order.\n\t *\n\t * @name dir\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {AsyncFunction} function - The function you want to eventually apply\n\t * all arguments to.\n\t * @param {...*} arguments... - Any number of arguments to apply to the function.\n\t * @example\n\t *\n\t * // in a module\n\t * var hello = function(name, callback) {\n\t *     setTimeout(function() {\n\t *         callback(null, {hello: name});\n\t *     }, 1000);\n\t * };\n\t *\n\t * // in the node repl\n\t * node> async.dir(hello, 'world');\n\t * {hello: 'world'}\n\t */\n\tvar dir = consoleFunc('dir');\n\n\t/**\n\t * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n\t * the order of operations, the arguments `test` and `fn` are switched.\n\t *\n\t * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n\t * @name doDuring\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.during]{@link module:ControlFlow.during}\n\t * @category Control Flow\n\t * @param {AsyncFunction} fn - An async function which is called each time\n\t * `test` passes. Invoked with (callback).\n\t * @param {AsyncFunction} test - asynchronous truth test to perform before each\n\t * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n\t * non-error args from the previous callback of `fn`.\n\t * @param {Function} [callback] - A callback which is called after the test\n\t * function has failed and repeated execution of `fn` has stopped. `callback`\n\t * will be passed an error if one occurred, otherwise `null`.\n\t */\n\tfunction doDuring(fn, test, callback) {\n\t\tcallback = onlyOnce(callback || noop);\n\t\tvar _fn = wrapAsync(fn);\n\t\tvar _test = wrapAsync(test);\n\n\t\tfunction next(err/*, ...args*/) {\n\t\t\tif (err) return callback(err);\n\t\t\tvar args = slice(arguments, 1);\n\t\t\targs.push(check);\n\t\t\t_test.apply(this, args);\n\t\t}\n\n\t\tfunction check(err, truth) {\n\t\t\tif (err) return callback(err);\n\t\t\tif (!truth) return callback(null);\n\t\t\t_fn(next);\n\t\t}\n\n\t\tcheck(null, true);\n\n\t}\n\n\t/**\n\t * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n\t * the order of operations, the arguments `test` and `iteratee` are switched.\n\t *\n\t * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n\t *\n\t * @name doWhilst\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.whilst]{@link module:ControlFlow.whilst}\n\t * @category Control Flow\n\t * @param {AsyncFunction} iteratee - A function which is called each time `test`\n\t * passes. Invoked with (callback).\n\t * @param {Function} test - synchronous truth test to perform after each\n\t * execution of `iteratee`. Invoked with any non-error callback results of\n\t * `iteratee`.\n\t * @param {Function} [callback] - A callback which is called after the test\n\t * function has failed and repeated execution of `iteratee` has stopped.\n\t * `callback` will be passed an error and any arguments passed to the final\n\t * `iteratee`'s callback. Invoked with (err, [results]);\n\t */\n\tfunction doWhilst(iteratee, test, callback) {\n\t\tcallback = onlyOnce(callback || noop);\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\tvar next = function (err/*, ...args*/) {\n\t\t\tif (err) return callback(err);\n\t\t\tvar args = slice(arguments, 1);\n\t\t\tif (test.apply(this, args)) return _iteratee(next);\n\t\t\tcallback.apply(null, [null].concat(args));\n\t\t};\n\t\t_iteratee(next);\n\t}\n\n\t/**\n\t * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n\t * argument ordering differs from `until`.\n\t *\n\t * @name doUntil\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n\t * @category Control Flow\n\t * @param {AsyncFunction} iteratee - An async function which is called each time\n\t * `test` fails. Invoked with (callback).\n\t * @param {Function} test - synchronous truth test to perform after each\n\t * execution of `iteratee`. Invoked with any non-error callback results of\n\t * `iteratee`.\n\t * @param {Function} [callback] - A callback which is called after the test\n\t * function has passed and repeated execution of `iteratee` has stopped. `callback`\n\t * will be passed an error and any arguments passed to the final `iteratee`'s\n\t * callback. Invoked with (err, [results]);\n\t */\n\tfunction doUntil(iteratee, test, callback) {\n\t\tdoWhilst(iteratee, function () {\n\t\t\treturn !test.apply(this, arguments);\n\t\t}, callback);\n\t}\n\n\t/**\n\t * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n\t * is passed a callback in the form of `function (err, truth)`. If error is\n\t * passed to `test` or `fn`, the main callback is immediately called with the\n\t * value of the error.\n\t *\n\t * @name during\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.whilst]{@link module:ControlFlow.whilst}\n\t * @category Control Flow\n\t * @param {AsyncFunction} test - asynchronous truth test to perform before each\n\t * execution of `fn`. Invoked with (callback).\n\t * @param {AsyncFunction} fn - An async function which is called each time\n\t * `test` passes. Invoked with (callback).\n\t * @param {Function} [callback] - A callback which is called after the test\n\t * function has failed and repeated execution of `fn` has stopped. `callback`\n\t * will be passed an error, if one occurred, otherwise `null`.\n\t * @example\n\t *\n\t * var count = 0;\n\t *\n\t * async.during(\n\t *     function (callback) {\n\t *         return callback(null, count < 5);\n\t *     },\n\t *     function (callback) {\n\t *         count++;\n\t *         setTimeout(callback, 1000);\n\t *     },\n\t *     function (err) {\n\t *         // 5 seconds have passed\n\t *     }\n\t * );\n\t */\n\tfunction during(test, fn, callback) {\n\t\tcallback = onlyOnce(callback || noop);\n\t\tvar _fn = wrapAsync(fn);\n\t\tvar _test = wrapAsync(test);\n\n\t\tfunction next(err) {\n\t\t\tif (err) return callback(err);\n\t\t\t_test(check);\n\t\t}\n\n\t\tfunction check(err, truth) {\n\t\t\tif (err) return callback(err);\n\t\t\tif (!truth) return callback(null);\n\t\t\t_fn(next);\n\t\t}\n\n\t\t_test(check);\n\t}\n\n\tfunction _withoutIndex(iteratee) {\n\t\treturn function (value, index, callback) {\n\t\t\treturn iteratee(value, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Applies the function `iteratee` to each item in `coll`, in parallel.\n\t * The `iteratee` is called with an item from the list, and a callback for when\n\t * it has finished. If the `iteratee` passes an error to its `callback`, the\n\t * main `callback` (for the `each` function) is immediately called with the\n\t * error.\n\t *\n\t * Note, that since this function applies `iteratee` to each item in parallel,\n\t * there is no guarantee that the iteratee functions will complete in order.\n\t *\n\t * @name each\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias forEach\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to\n\t * each item in `coll`. Invoked with (item, callback).\n\t * The array index is not passed to the iteratee.\n\t * If you need the index, use `eachOf`.\n\t * @param {Function} [callback] - A callback which is called when all\n\t * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n\t * @example\n\t *\n\t * // assuming openFiles is an array of file names and saveFile is a function\n\t * // to save the modified contents of that file:\n\t *\n\t * async.each(openFiles, saveFile, function(err){\n\t *   // if any of the saves produced an error, err would equal that error\n\t * });\n\t *\n\t * // assuming openFiles is an array of file names\n\t * async.each(openFiles, function(file, callback) {\n\t *\n\t *     // Perform operation on file here.\n\t *     console.log('Processing file ' + file);\n\t *\n\t *     if( file.length > 32 ) {\n\t *       console.log('This file name is too long');\n\t *       callback('File name too long');\n\t *     } else {\n\t *       // Do work to process file here\n\t *       console.log('File processed');\n\t *       callback();\n\t *     }\n\t * }, function(err) {\n\t *     // if any of the file processing produced an error, err would equal that error\n\t *     if( err ) {\n\t *       // One of the iterations produced an error.\n\t *       // All processing will now stop.\n\t *       console.log('A file failed to process');\n\t *     } else {\n\t *       console.log('All files have been processed successfully');\n\t *     }\n\t * });\n\t */\n\tfunction eachLimit(coll, iteratee, callback) {\n\t\teachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n\t}\n\n\t/**\n\t * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n\t *\n\t * @name eachLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.each]{@link module:Collections.each}\n\t * @alias forEachLimit\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The array index is not passed to the iteratee.\n\t * If you need the index, use `eachOfLimit`.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called when all\n\t * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n\t */\n\tfunction eachLimit$1(coll, limit, iteratee, callback) {\n\t\t_eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n\t}\n\n\t/**\n\t * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n\t *\n\t * @name eachSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.each]{@link module:Collections.each}\n\t * @alias forEachSeries\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each\n\t * item in `coll`.\n\t * The array index is not passed to the iteratee.\n\t * If you need the index, use `eachOfSeries`.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called when all\n\t * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n\t */\n\tvar eachSeries = doLimit(eachLimit$1, 1);\n\n\t/**\n\t * Wrap an async function and ensure it calls its callback on a later tick of\n\t * the event loop.  If the function already calls its callback on a next tick,\n\t * no extra deferral is added. This is useful for preventing stack overflows\n\t * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n\t * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n\t * contained. ES2017 `async` functions are returned as-is -- they are immune\n\t * to Zalgo's corrupting influences, as they always resolve on a later tick.\n\t *\n\t * @name ensureAsync\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {AsyncFunction} fn - an async function, one that expects a node-style\n\t * callback as its last argument.\n\t * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n\t * signature as the function passed in.\n\t * @example\n\t *\n\t * function sometimesAsync(arg, callback) {\n\t *     if (cache[arg]) {\n\t *         return callback(null, cache[arg]); // this would be synchronous!!\n\t *     } else {\n\t *         doSomeIO(arg, callback); // this IO would be asynchronous\n\t *     }\n\t * }\n\t *\n\t * // this has a risk of stack overflows if many results are cached in a row\n\t * async.mapSeries(args, sometimesAsync, done);\n\t *\n\t * // this will defer sometimesAsync's callback if necessary,\n\t * // preventing stack overflows\n\t * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n\t */\n\tfunction ensureAsync(fn) {\n\t\tif (isAsync(fn)) return fn;\n\t\treturn initialParams(function (args, callback) {\n\t\t\tvar sync = true;\n\t\t\targs.push(function () {\n\t\t\t\tvar innerArgs = arguments;\n\t\t\t\tif (sync) {\n\t\t\t\t\tsetImmediate$1(function () {\n\t\t\t\t\t\tcallback.apply(null, innerArgs);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback.apply(null, innerArgs);\n\t\t\t\t}\n\t\t\t});\n\t\t\tfn.apply(this, args);\n\t\t\tsync = false;\n\t\t});\n\t}\n\n\tfunction notId(v) {\n\t\treturn !v;\n\t}\n\n\t/**\n\t * Returns `true` if every element in `coll` satisfies an async test. If any\n\t * iteratee call returns `false`, the main `callback` is immediately called.\n\t *\n\t * @name every\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias all\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n\t * in the collection in parallel.\n\t * The iteratee must complete with a boolean result value.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Result will be either `true` or `false`\n\t * depending on the values of the async tests. Invoked with (err, result).\n\t * @example\n\t *\n\t * async.every(['file1','file2','file3'], function(filePath, callback) {\n\t *     fs.access(filePath, function(err) {\n\t *         callback(null, !err)\n\t *     });\n\t * }, function(err, result) {\n\t *     // if result is true then every file exists\n\t * });\n\t */\n\tvar every = doParallel(_createTester(notId, notId));\n\n\t/**\n\t * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n\t *\n\t * @name everyLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.every]{@link module:Collections.every}\n\t * @alias allLimit\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n\t * in the collection in parallel.\n\t * The iteratee must complete with a boolean result value.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Result will be either `true` or `false`\n\t * depending on the values of the async tests. Invoked with (err, result).\n\t */\n\tvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n\t/**\n\t * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n\t *\n\t * @name everySeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.every]{@link module:Collections.every}\n\t * @alias allSeries\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n\t * in the collection in series.\n\t * The iteratee must complete with a boolean result value.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Result will be either `true` or `false`\n\t * depending on the values of the async tests. Invoked with (err, result).\n\t */\n\tvar everySeries = doLimit(everyLimit, 1);\n\n\t/**\n\t * The base implementation of `_.property` without support for deep paths.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t */\n\tfunction baseProperty(key) {\n\t\treturn function (object) {\n\t\t\treturn object == null ? undefined : object[key];\n\t\t};\n\t}\n\n\tfunction filterArray(eachfn, arr, iteratee, callback) {\n\t\tvar truthValues = new Array(arr.length);\n\t\teachfn(arr, function (x, index, callback) {\n\t\t\titeratee(x, function (err, v) {\n\t\t\t\ttruthValues[index] = !!v;\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tif (err) return callback(err);\n\t\t\tvar results = [];\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tif (truthValues[i]) results.push(arr[i]);\n\t\t\t}\n\t\t\tcallback(null, results);\n\t\t});\n\t}\n\n\tfunction filterGeneric(eachfn, coll, iteratee, callback) {\n\t\tvar results = [];\n\t\teachfn(coll, function (x, index, callback) {\n\t\t\titeratee(x, function (err, v) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else {\n\t\t\t\t\tif (v) {\n\t\t\t\t\t\tresults.push({ index: index, value: x });\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tcallback(null, arrayMap(results.sort(function (a, b) {\n\t\t\t\t\treturn a.index - b.index;\n\t\t\t\t}), baseProperty('value')));\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction _filter(eachfn, coll, iteratee, callback) {\n\t\tvar filter = isArrayLike(coll) ? filterArray : filterGeneric;\n\t\tfilter(eachfn, coll, wrapAsync(iteratee), callback || noop);\n\t}\n\n\t/**\n\t * Returns a new array of all the values in `coll` which pass an async truth\n\t * test. This operation is performed in parallel, but the results array will be\n\t * in the same order as the original.\n\t *\n\t * @name filter\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias select\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n\t * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n\t * with a boolean argument once it has completed. Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Invoked with (err, results).\n\t * @example\n\t *\n\t * async.filter(['file1','file2','file3'], function(filePath, callback) {\n\t *     fs.access(filePath, function(err) {\n\t *         callback(null, !err)\n\t *     });\n\t * }, function(err, results) {\n\t *     // results now equals an array of the existing files\n\t * });\n\t */\n\tvar filter = doParallel(_filter);\n\n\t/**\n\t * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name filterLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.filter]{@link module:Collections.filter}\n\t * @alias selectLimit\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n\t * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n\t * with a boolean argument once it has completed. Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Invoked with (err, results).\n\t */\n\tvar filterLimit = doParallelLimit(_filter);\n\n\t/**\n\t * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n\t *\n\t * @name filterSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.filter]{@link module:Collections.filter}\n\t * @alias selectSeries\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n\t * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n\t * with a boolean argument once it has completed. Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Invoked with (err, results)\n\t */\n\tvar filterSeries = doLimit(filterLimit, 1);\n\n\t/**\n\t * Calls the asynchronous function `fn` with a callback parameter that allows it\n\t * to call itself again, in series, indefinitely.\n\t\n\t * If an error is passed to the callback then `errback` is called with the\n\t * error, and execution stops, otherwise it will never be called.\n\t *\n\t * @name forever\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {AsyncFunction} fn - an async function to call repeatedly.\n\t * Invoked with (next).\n\t * @param {Function} [errback] - when `fn` passes an error to it's callback,\n\t * this function will be called, and execution stops. Invoked with (err).\n\t * @example\n\t *\n\t * async.forever(\n\t *     function(next) {\n\t *         // next is suitable for passing to things that need a callback(err [, whatever]);\n\t *         // it will result in this function being called again.\n\t *     },\n\t *     function(err) {\n\t *         // if next is called with a value in its first parameter, it will appear\n\t *         // in here as 'err', and execution will stop.\n\t *     }\n\t * );\n\t */\n\tfunction forever(fn, errback) {\n\t\tvar done = onlyOnce(errback || noop);\n\t\tvar task = wrapAsync(ensureAsync(fn));\n\n\t\tfunction next(err) {\n\t\t\tif (err) return done(err);\n\t\t\ttask(next);\n\t\t}\n\t\tnext();\n\t}\n\n\t/**\n\t * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n\t *\n\t * @name groupByLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.groupBy]{@link module:Collections.groupBy}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with a `key` to group the value under.\n\t * Invoked with (value, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Result is an `Object` whoses\n\t * properties are arrays of values which returned the corresponding key.\n\t */\n\tvar groupByLimit = function (coll, limit, iteratee, callback) {\n\t\tcallback = callback || noop;\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\tmapLimit(coll, limit, function (val, callback) {\n\t\t\t_iteratee(val, function (err, key) {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\treturn callback(null, { key: key, val: val });\n\t\t\t});\n\t\t}, function (err, mapResults) {\n\t\t\tvar result = {};\n\t\t\t// from MDN, handle object having an `hasOwnProperty` prop\n\t\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\t\t\tfor (var i = 0; i < mapResults.length; i++) {\n\t\t\t\tif (mapResults[i]) {\n\t\t\t\t\tvar key = mapResults[i].key;\n\t\t\t\t\tvar val = mapResults[i].val;\n\n\t\t\t\t\tif (hasOwnProperty.call(result, key)) {\n\t\t\t\t\t\tresult[key].push(val);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[key] = [val];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn callback(err, result);\n\t\t});\n\t};\n\n\t/**\n\t * Returns a new object, where each value corresponds to an array of items, from\n\t * `coll`, that returned the corresponding key. That is, the keys of the object\n\t * correspond to the values passed to the `iteratee` callback.\n\t *\n\t * Note: Since this function applies the `iteratee` to each item in parallel,\n\t * there is no guarantee that the `iteratee` functions will complete in order.\n\t * However, the values for each key in the `result` will be in the same order as\n\t * the original `coll`. For Objects, the values will roughly be in the order of\n\t * the original Objects' keys (but this can vary across JavaScript engines).\n\t *\n\t * @name groupBy\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with a `key` to group the value under.\n\t * Invoked with (value, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Result is an `Object` whoses\n\t * properties are arrays of values which returned the corresponding key.\n\t * @example\n\t *\n\t * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n\t *     db.findById(userId, function(err, user) {\n\t *         if (err) return callback(err);\n\t *         return callback(null, user.age);\n\t *     });\n\t * }, function(err, result) {\n\t *     // result is object containing the userIds grouped by age\n\t *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n\t * });\n\t */\n\tvar groupBy = doLimit(groupByLimit, Infinity);\n\n\t/**\n\t * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n\t *\n\t * @name groupBySeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.groupBy]{@link module:Collections.groupBy}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with a `key` to group the value under.\n\t * Invoked with (value, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. Result is an `Object` whoses\n\t * properties are arrays of values which returned the corresponding key.\n\t */\n\tvar groupBySeries = doLimit(groupByLimit, 1);\n\n\t/**\n\t * Logs the result of an `async` function to the `console`. Only works in\n\t * Node.js or in browsers that support `console.log` and `console.error` (such\n\t * as FF and Chrome). If multiple arguments are returned from the async\n\t * function, `console.log` is called on each argument in order.\n\t *\n\t * @name log\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {AsyncFunction} function - The function you want to eventually apply\n\t * all arguments to.\n\t * @param {...*} arguments... - Any number of arguments to apply to the function.\n\t * @example\n\t *\n\t * // in a module\n\t * var hello = function(name, callback) {\n\t *     setTimeout(function() {\n\t *         callback(null, 'hello ' + name);\n\t *     }, 1000);\n\t * };\n\t *\n\t * // in the node repl\n\t * node> async.log(hello, 'world');\n\t * 'hello world'\n\t */\n\tvar log = consoleFunc('log');\n\n\t/**\n\t * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name mapValuesLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.mapValues]{@link module:Collections.mapValues}\n\t * @category Collection\n\t * @param {Object} obj - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - A function to apply to each value and key\n\t * in `coll`.\n\t * The iteratee should complete with the transformed value as its result.\n\t * Invoked with (value, key, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. `result` is a new object consisting\n\t * of each key from `obj`, with each transformed value on the right-hand side.\n\t * Invoked with (err, result).\n\t */\n\tfunction mapValuesLimit(obj, limit, iteratee, callback) {\n\t\tcallback = once(callback || noop);\n\t\tvar newObj = {};\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\teachOfLimit(obj, limit, function (val, key, next) {\n\t\t\t_iteratee(val, key, function (err, result) {\n\t\t\t\tif (err) return next(err);\n\t\t\t\tnewObj[key] = result;\n\t\t\t\tnext();\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tcallback(err, newObj);\n\t\t});\n\t}\n\n\t/**\n\t * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n\t *\n\t * Produces a new Object by mapping each value of `obj` through the `iteratee`\n\t * function. The `iteratee` is called each `value` and `key` from `obj` and a\n\t * callback for when it has finished processing. Each of these callbacks takes\n\t * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n\t * passes an error to its callback, the main `callback` (for the `mapValues`\n\t * function) is immediately called with the error.\n\t *\n\t * Note, the order of the keys in the result is not guaranteed.  The keys will\n\t * be roughly in the order they complete, (but this is very engine-specific)\n\t *\n\t * @name mapValues\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @category Collection\n\t * @param {Object} obj - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A function to apply to each value and key\n\t * in `coll`.\n\t * The iteratee should complete with the transformed value as its result.\n\t * Invoked with (value, key, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. `result` is a new object consisting\n\t * of each key from `obj`, with each transformed value on the right-hand side.\n\t * Invoked with (err, result).\n\t * @example\n\t *\n\t * async.mapValues({\n\t *     f1: 'file1',\n\t *     f2: 'file2',\n\t *     f3: 'file3'\n\t * }, function (file, key, callback) {\n\t *   fs.stat(file, callback);\n\t * }, function(err, result) {\n\t *     // result is now a map of stats for each file, e.g.\n\t *     // {\n\t *     //     f1: [stats for file1],\n\t *     //     f2: [stats for file2],\n\t *     //     f3: [stats for file3]\n\t *     // }\n\t * });\n\t */\n\n\tvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n\t/**\n\t * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n\t *\n\t * @name mapValuesSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.mapValues]{@link module:Collections.mapValues}\n\t * @category Collection\n\t * @param {Object} obj - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - A function to apply to each value and key\n\t * in `coll`.\n\t * The iteratee should complete with the transformed value as its result.\n\t * Invoked with (value, key, callback).\n\t * @param {Function} [callback] - A callback which is called when all `iteratee`\n\t * functions have finished, or an error occurs. `result` is a new object consisting\n\t * of each key from `obj`, with each transformed value on the right-hand side.\n\t * Invoked with (err, result).\n\t */\n\tvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\n\tfunction has(obj, key) {\n\t\treturn key in obj;\n\t}\n\n\t/**\n\t * Caches the results of an async function. When creating a hash to store\n\t * function results against, the callback is omitted from the hash and an\n\t * optional hash function can be used.\n\t *\n\t * If no hash function is specified, the first argument is used as a hash key,\n\t * which may work reasonably if it is a string or a data type that converts to a\n\t * distinct string. Note that objects and arrays will not behave reasonably.\n\t * Neither will cases where the other arguments are significant. In such cases,\n\t * specify your own hash function.\n\t *\n\t * The cache of results is exposed as the `memo` property of the function\n\t * returned by `memoize`.\n\t *\n\t * @name memoize\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n\t * @param {Function} hasher - An optional function for generating a custom hash\n\t * for storing results. It has all the arguments applied to it apart from the\n\t * callback, and must be synchronous.\n\t * @returns {AsyncFunction} a memoized version of `fn`\n\t * @example\n\t *\n\t * var slow_fn = function(name, callback) {\n\t *     // do something\n\t *     callback(null, result);\n\t * };\n\t * var fn = async.memoize(slow_fn);\n\t *\n\t * // fn can now be used as if it were slow_fn\n\t * fn('some name', function() {\n\t *     // callback\n\t * });\n\t */\n\tfunction memoize(fn, hasher) {\n\t\tvar memo = Object.create(null);\n\t\tvar queues = Object.create(null);\n\t\thasher = hasher || identity;\n\t\tvar _fn = wrapAsync(fn);\n\t\tvar memoized = initialParams(function memoized(args, callback) {\n\t\t\tvar key = hasher.apply(null, args);\n\t\t\tif (has(memo, key)) {\n\t\t\t\tsetImmediate$1(function () {\n\t\t\t\t\tcallback.apply(null, memo[key]);\n\t\t\t\t});\n\t\t\t} else if (has(queues, key)) {\n\t\t\t\tqueues[key].push(callback);\n\t\t\t} else {\n\t\t\t\tqueues[key] = [callback];\n\t\t\t\t_fn.apply(null, args.concat(function (/*args*/) {\n\t\t\t\t\tvar args = slice(arguments);\n\t\t\t\t\tmemo[key] = args;\n\t\t\t\t\tvar q = queues[key];\n\t\t\t\t\tdelete queues[key];\n\t\t\t\t\tfor (var i = 0, l = q.length; i < l; i++) {\n\t\t\t\t\t\tq[i].apply(null, args);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t\tmemoized.memo = memo;\n\t\tmemoized.unmemoized = fn;\n\t\treturn memoized;\n\t}\n\n\t/**\n\t * Calls `callback` on a later loop around the event loop. In Node.js this just\n\t * calls `setImmediate`.  In the browser it will use `setImmediate` if\n\t * available, otherwise `setTimeout(callback, 0)`, which means other higher\n\t * priority events may precede the execution of `callback`.\n\t *\n\t * This is used internally for browser-compatibility purposes.\n\t *\n\t * @name nextTick\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @alias setImmediate\n\t * @category Util\n\t * @param {Function} callback - The function to call on a later loop around\n\t * the event loop. Invoked with (args...).\n\t * @param {...*} args... - any number of additional arguments to pass to the\n\t * callback on the next tick.\n\t * @example\n\t *\n\t * var call_order = [];\n\t * async.nextTick(function() {\n\t *     call_order.push('two');\n\t *     // call_order now equals ['one','two']\n\t * });\n\t * call_order.push('one');\n\t *\n\t * async.setImmediate(function (a, b, c) {\n\t *     // a, b, and c equal 1, 2, and 3\n\t * }, 1, 2, 3);\n\t */\n\tvar _defer$1;\n\n\tif (hasNextTick) {\n\t\t_defer$1 = process.nextTick;\n\t} else if (hasSetImmediate) {\n\t\t_defer$1 = setImmediate;\n\t} else {\n\t\t_defer$1 = fallback;\n\t}\n\n\tvar nextTick = wrap(_defer$1);\n\n\tfunction _parallel(eachfn, tasks, callback) {\n\t\tcallback = callback || noop;\n\t\tvar results = isArrayLike(tasks) ? [] : {};\n\n\t\teachfn(tasks, function (task, key, callback) {\n\t\t\twrapAsync(task)(function (err, result) {\n\t\t\t\tif (arguments.length > 2) {\n\t\t\t\t\tresult = slice(arguments, 1);\n\t\t\t\t}\n\t\t\t\tresults[key] = result;\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t}, function (err) {\n\t\t\tcallback(err, results);\n\t\t});\n\t}\n\n\t/**\n\t * Run the `tasks` collection of functions in parallel, without waiting until\n\t * the previous function has completed. If any of the functions pass an error to\n\t * its callback, the main `callback` is immediately called with the value of the\n\t * error. Once the `tasks` have completed, the results are passed to the final\n\t * `callback` as an array.\n\t *\n\t * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n\t * parallel execution of code.  If your tasks do not use any timers or perform\n\t * any I/O, they will actually be executed in series.  Any synchronous setup\n\t * sections for each task will happen one after the other.  JavaScript remains\n\t * single-threaded.\n\t *\n\t * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n\t * execution of other tasks when a task fails.\n\t *\n\t * It is also possible to use an object instead of an array. Each property will\n\t * be run as a function and the results will be passed to the final `callback`\n\t * as an object instead of an array. This can be a more readable way of handling\n\t * results from {@link async.parallel}.\n\t *\n\t * @name parallel\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Array|Iterable|Object} tasks - A collection of\n\t * [async functions]{@link AsyncFunction} to run.\n\t * Each async function can complete with any number of optional `result` values.\n\t * @param {Function} [callback] - An optional callback to run once all the\n\t * functions have completed successfully. This function gets a results array\n\t * (or object) containing all the result arguments passed to the task callbacks.\n\t * Invoked with (err, results).\n\t *\n\t * @example\n\t * async.parallel([\n\t *     function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'one');\n\t *         }, 200);\n\t *     },\n\t *     function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'two');\n\t *         }, 100);\n\t *     }\n\t * ],\n\t * // optional callback\n\t * function(err, results) {\n\t *     // the results array will equal ['one','two'] even though\n\t *     // the second function had a shorter timeout.\n\t * });\n\t *\n\t * // an example using an object instead of an array\n\t * async.parallel({\n\t *     one: function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 1);\n\t *         }, 200);\n\t *     },\n\t *     two: function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 2);\n\t *         }, 100);\n\t *     }\n\t * }, function(err, results) {\n\t *     // results is now equals to: {one: 1, two: 2}\n\t * });\n\t */\n\tfunction parallelLimit(tasks, callback) {\n\t\t_parallel(eachOf, tasks, callback);\n\t}\n\n\t/**\n\t * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name parallelLimit\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.parallel]{@link module:ControlFlow.parallel}\n\t * @category Control Flow\n\t * @param {Array|Iterable|Object} tasks - A collection of\n\t * [async functions]{@link AsyncFunction} to run.\n\t * Each async function can complete with any number of optional `result` values.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {Function} [callback] - An optional callback to run once all the\n\t * functions have completed successfully. This function gets a results array\n\t * (or object) containing all the result arguments passed to the task callbacks.\n\t * Invoked with (err, results).\n\t */\n\tfunction parallelLimit$1(tasks, limit, callback) {\n\t\t_parallel(_eachOfLimit(limit), tasks, callback);\n\t}\n\n\t/**\n\t * A queue of tasks for the worker function to complete.\n\t * @typedef {Object} QueueObject\n\t * @memberOf module:ControlFlow\n\t * @property {Function} length - a function returning the number of items\n\t * waiting to be processed. Invoke with `queue.length()`.\n\t * @property {boolean} started - a boolean indicating whether or not any\n\t * items have been pushed and processed by the queue.\n\t * @property {Function} running - a function returning the number of items\n\t * currently being processed. Invoke with `queue.running()`.\n\t * @property {Function} workersList - a function returning the array of items\n\t * currently being processed. Invoke with `queue.workersList()`.\n\t * @property {Function} idle - a function returning false if there are items\n\t * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n\t * @property {number} concurrency - an integer for determining how many `worker`\n\t * functions should be run in parallel. This property can be changed after a\n\t * `queue` is created to alter the concurrency on-the-fly.\n\t * @property {Function} push - add a new task to the `queue`. Calls `callback`\n\t * once the `worker` has finished processing the task. Instead of a single task,\n\t * a `tasks` array can be submitted. The respective callback is used for every\n\t * task in the list. Invoke with `queue.push(task, [callback])`,\n\t * @property {Function} unshift - add a new task to the front of the `queue`.\n\t * Invoke with `queue.unshift(task, [callback])`.\n\t * @property {Function} remove - remove items from the queue that match a test\n\t * function.  The test function will be passed an object with a `data` property,\n\t * and a `priority` property, if this is a\n\t * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n\t * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n\t * `function ({data, priority}) {}` and returns a Boolean.\n\t * @property {Function} saturated - a callback that is called when the number of\n\t * running workers hits the `concurrency` limit, and further tasks will be\n\t * queued.\n\t * @property {Function} unsaturated - a callback that is called when the number\n\t * of running workers is less than the `concurrency` & `buffer` limits, and\n\t * further tasks will not be queued.\n\t * @property {number} buffer - A minimum threshold buffer in order to say that\n\t * the `queue` is `unsaturated`.\n\t * @property {Function} empty - a callback that is called when the last item\n\t * from the `queue` is given to a `worker`.\n\t * @property {Function} drain - a callback that is called when the last item\n\t * from the `queue` has returned from the `worker`.\n\t * @property {Function} error - a callback that is called when a task errors.\n\t * Has the signature `function(error, task)`.\n\t * @property {boolean} paused - a boolean for determining whether the queue is\n\t * in a paused state.\n\t * @property {Function} pause - a function that pauses the processing of tasks\n\t * until `resume()` is called. Invoke with `queue.pause()`.\n\t * @property {Function} resume - a function that resumes the processing of\n\t * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n\t * @property {Function} kill - a function that removes the `drain` callback and\n\t * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.\n\t */\n\n\t/**\n\t * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n\t * `queue` are processed in parallel (up to the `concurrency` limit). If all\n\t * `worker`s are in progress, the task is queued until one becomes available.\n\t * Once a `worker` completes a `task`, that `task`'s callback is called.\n\t *\n\t * @name queue\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {AsyncFunction} worker - An async function for processing a queued task.\n\t * If you want to handle errors from an individual task, pass a callback to\n\t * `q.push()`. Invoked with (task, callback).\n\t * @param {number} [concurrency=1] - An `integer` for determining how many\n\t * `worker` functions should be run in parallel.  If omitted, the concurrency\n\t * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n\t * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n\t * attached as certain properties to listen for specific events during the\n\t * lifecycle of the queue.\n\t * @example\n\t *\n\t * // create a queue object with concurrency 2\n\t * var q = async.queue(function(task, callback) {\n\t *     console.log('hello ' + task.name);\n\t *     callback();\n\t * }, 2);\n\t *\n\t * // assign a callback\n\t * q.drain = function() {\n\t *     console.log('all items have been processed');\n\t * };\n\t *\n\t * // add some items to the queue\n\t * q.push({name: 'foo'}, function(err) {\n\t *     console.log('finished processing foo');\n\t * });\n\t * q.push({name: 'bar'}, function (err) {\n\t *     console.log('finished processing bar');\n\t * });\n\t *\n\t * // add some items to the queue (batch-wise)\n\t * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n\t *     console.log('finished processing item');\n\t * });\n\t *\n\t * // add some items to the front of the queue\n\t * q.unshift({name: 'bar'}, function (err) {\n\t *     console.log('finished processing bar');\n\t * });\n\t */\n\tvar queue$1 = function (worker, concurrency) {\n\t\tvar _worker = wrapAsync(worker);\n\t\treturn queue(function (items, cb) {\n\t\t\t_worker(items[0], cb);\n\t\t}, concurrency, 1);\n\t};\n\n\t/**\n\t * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n\t * completed in ascending priority order.\n\t *\n\t * @name priorityQueue\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.queue]{@link module:ControlFlow.queue}\n\t * @category Control Flow\n\t * @param {AsyncFunction} worker - An async function for processing a queued task.\n\t * If you want to handle errors from an individual task, pass a callback to\n\t * `q.push()`.\n\t * Invoked with (task, callback).\n\t * @param {number} concurrency - An `integer` for determining how many `worker`\n\t * functions should be run in parallel.  If omitted, the concurrency defaults to\n\t * `1`.  If the concurrency is `0`, an error is thrown.\n\t * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n\t * differences between `queue` and `priorityQueue` objects:\n\t * * `push(task, priority, [callback])` - `priority` should be a number. If an\n\t *   array of `tasks` is given, all tasks will be assigned the same priority.\n\t * * The `unshift` method was removed.\n\t */\n\tvar priorityQueue = function (worker, concurrency) {\n\t\t// Start with a normal queue\n\t\tvar q = queue$1(worker, concurrency);\n\n\t\t// Override push to accept second parameter representing priority\n\t\tq.push = function (data, priority, callback) {\n\t\t\tif (callback == null) callback = noop;\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('task callback must be a function');\n\t\t\t}\n\t\t\tq.started = true;\n\t\t\tif (!isArray(data)) {\n\t\t\t\tdata = [data];\n\t\t\t}\n\t\t\tif (data.length === 0) {\n\t\t\t\t// call drain immediately if there are no tasks\n\t\t\t\treturn setImmediate$1(function () {\n\t\t\t\t\tq.drain();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpriority = priority || 0;\n\t\t\tvar nextNode = q._tasks.head;\n\t\t\twhile (nextNode && priority >= nextNode.priority) {\n\t\t\t\tnextNode = nextNode.next;\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = data.length; i < l; i++) {\n\t\t\t\tvar item = {\n\t\t\t\t\tdata: data[i],\n\t\t\t\t\tpriority: priority,\n\t\t\t\t\tcallback: callback\n\t\t\t\t};\n\n\t\t\t\tif (nextNode) {\n\t\t\t\t\tq._tasks.insertBefore(nextNode, item);\n\t\t\t\t} else {\n\t\t\t\t\tq._tasks.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetImmediate$1(q.process);\n\t\t};\n\n\t\t// Remove unshift function\n\t\tdelete q.unshift;\n\n\t\treturn q;\n\t};\n\n\t/**\n\t * Runs the `tasks` array of functions in parallel, without waiting until the\n\t * previous function has completed. Once any of the `tasks` complete or pass an\n\t * error to its callback, the main `callback` is immediately called. It's\n\t * equivalent to `Promise.race()`.\n\t *\n\t * @name race\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n\t * to run. Each function can complete with an optional `result` value.\n\t * @param {Function} callback - A callback to run once any of the functions have\n\t * completed. This function gets an error or result from the first function that\n\t * completed. Invoked with (err, result).\n\t * @returns undefined\n\t * @example\n\t *\n\t * async.race([\n\t *     function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'one');\n\t *         }, 200);\n\t *     },\n\t *     function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'two');\n\t *         }, 100);\n\t *     }\n\t * ],\n\t * // main callback\n\t * function(err, result) {\n\t *     // the result will be equal to 'two' as it finishes earlier\n\t * });\n\t */\n\tfunction race(tasks, callback) {\n\t\tcallback = once(callback || noop);\n\t\tif (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n\t\tif (!tasks.length) return callback();\n\t\tfor (var i = 0, l = tasks.length; i < l; i++) {\n\t\t\twrapAsync(tasks[i])(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n\t *\n\t * @name reduceRight\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.reduce]{@link module:Collections.reduce}\n\t * @alias foldr\n\t * @category Collection\n\t * @param {Array} array - A collection to iterate over.\n\t * @param {*} memo - The initial state of the reduction.\n\t * @param {AsyncFunction} iteratee - A function applied to each item in the\n\t * array to produce the next step in the reduction.\n\t * The `iteratee` should complete with the next state of the reduction.\n\t * If the iteratee complete with an error, the reduction is stopped and the\n\t * main `callback` is immediately called with the error.\n\t * Invoked with (memo, item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Result is the reduced value. Invoked with\n\t * (err, result).\n\t */\n\tfunction reduceRight(array, memo, iteratee, callback) {\n\t\tvar reversed = slice(array).reverse();\n\t\treduce(reversed, memo, iteratee, callback);\n\t}\n\n\t/**\n\t * Wraps the async function in another function that always completes with a\n\t * result object, even when it errors.\n\t *\n\t * The result object has either the property `error` or `value`.\n\t *\n\t * @name reflect\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {AsyncFunction} fn - The async function you want to wrap\n\t * @returns {Function} - A function that always passes null to it's callback as\n\t * the error. The second argument to the callback will be an `object` with\n\t * either an `error` or a `value` property.\n\t * @example\n\t *\n\t * async.parallel([\n\t *     async.reflect(function(callback) {\n\t *         // do some stuff ...\n\t *         callback(null, 'one');\n\t *     }),\n\t *     async.reflect(function(callback) {\n\t *         // do some more stuff but error ...\n\t *         callback('bad stuff happened');\n\t *     }),\n\t *     async.reflect(function(callback) {\n\t *         // do some more stuff ...\n\t *         callback(null, 'two');\n\t *     })\n\t * ],\n\t * // optional callback\n\t * function(err, results) {\n\t *     // values\n\t *     // results[0].value = 'one'\n\t *     // results[1].error = 'bad stuff happened'\n\t *     // results[2].value = 'two'\n\t * });\n\t */\n\tfunction reflect(fn) {\n\t\tvar _fn = wrapAsync(fn);\n\t\treturn initialParams(function reflectOn(args, reflectCallback) {\n\t\t\targs.push(function callback(error, cbArg) {\n\t\t\t\tif (error) {\n\t\t\t\t\treflectCallback(null, { error: error });\n\t\t\t\t} else {\n\t\t\t\t\tvar value;\n\t\t\t\t\tif (arguments.length <= 2) {\n\t\t\t\t\t\tvalue = cbArg;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = slice(arguments, 1);\n\t\t\t\t\t}\n\t\t\t\t\treflectCallback(null, { value: value });\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn _fn.apply(this, args);\n\t\t});\n\t}\n\n\tfunction reject$1(eachfn, arr, iteratee, callback) {\n\t\t_filter(eachfn, arr, function (value, cb) {\n\t\t\titeratee(value, function (err, v) {\n\t\t\t\tcb(err, !v);\n\t\t\t});\n\t\t}, callback);\n\t}\n\n\t/**\n\t * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n\t *\n\t * @name reject\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.filter]{@link module:Collections.filter}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {Function} iteratee - An async truth test to apply to each item in\n\t * `coll`.\n\t * The should complete with a boolean value as its `result`.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Invoked with (err, results).\n\t * @example\n\t *\n\t * async.reject(['file1','file2','file3'], function(filePath, callback) {\n\t *     fs.access(filePath, function(err) {\n\t *         callback(null, !err)\n\t *     });\n\t * }, function(err, results) {\n\t *     // results now equals an array of missing files\n\t *     createFiles(results);\n\t * });\n\t */\n\tvar reject = doParallel(reject$1);\n\n\t/**\n\t * A helper function that wraps an array or an object of functions with `reflect`.\n\t *\n\t * @name reflectAll\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @see [async.reflect]{@link module:Utils.reflect}\n\t * @category Util\n\t * @param {Array|Object|Iterable} tasks - The collection of\n\t * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n\t * @returns {Array} Returns an array of async functions, each wrapped in\n\t * `async.reflect`\n\t * @example\n\t *\n\t * let tasks = [\n\t *     function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'one');\n\t *         }, 200);\n\t *     },\n\t *     function(callback) {\n\t *         // do some more stuff but error ...\n\t *         callback(new Error('bad stuff happened'));\n\t *     },\n\t *     function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'two');\n\t *         }, 100);\n\t *     }\n\t * ];\n\t *\n\t * async.parallel(async.reflectAll(tasks),\n\t * // optional callback\n\t * function(err, results) {\n\t *     // values\n\t *     // results[0].value = 'one'\n\t *     // results[1].error = Error('bad stuff happened')\n\t *     // results[2].value = 'two'\n\t * });\n\t *\n\t * // an example using an object instead of an array\n\t * let tasks = {\n\t *     one: function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'one');\n\t *         }, 200);\n\t *     },\n\t *     two: function(callback) {\n\t *         callback('two');\n\t *     },\n\t *     three: function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 'three');\n\t *         }, 100);\n\t *     }\n\t * };\n\t *\n\t * async.parallel(async.reflectAll(tasks),\n\t * // optional callback\n\t * function(err, results) {\n\t *     // values\n\t *     // results.one.value = 'one'\n\t *     // results.two.error = 'two'\n\t *     // results.three.value = 'three'\n\t * });\n\t */\n\tfunction reflectAll(tasks) {\n\t\tvar results;\n\t\tif (isArray(tasks)) {\n\t\t\tresults = arrayMap(tasks, reflect);\n\t\t} else {\n\t\t\tresults = {};\n\t\t\tbaseForOwn(tasks, function (task, key) {\n\t\t\t\tresults[key] = reflect.call(this, task);\n\t\t\t});\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name rejectLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.reject]{@link module:Collections.reject}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {Function} iteratee - An async truth test to apply to each item in\n\t * `coll`.\n\t * The should complete with a boolean value as its `result`.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Invoked with (err, results).\n\t */\n\tvar rejectLimit = doParallelLimit(reject$1);\n\n\t/**\n\t * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n\t *\n\t * @name rejectSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.reject]{@link module:Collections.reject}\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {Function} iteratee - An async truth test to apply to each item in\n\t * `coll`.\n\t * The should complete with a boolean value as its `result`.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Invoked with (err, results).\n\t */\n\tvar rejectSeries = doLimit(rejectLimit, 1);\n\n\t/**\n\t * Creates a function that returns `value`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Util\n\t * @param {*} value The value to return from the new function.\n\t * @returns {Function} Returns the new constant function.\n\t * @example\n\t *\n\t * var objects = _.times(2, _.constant({ 'a': 1 }));\n\t *\n\t * console.log(objects);\n\t * // => [{ 'a': 1 }, { 'a': 1 }]\n\t *\n\t * console.log(objects[0] === objects[1]);\n\t * // => true\n\t */\n\tfunction constant$1(value) {\n\t\treturn function () {\n\t\t\treturn value;\n\t\t};\n\t}\n\n\t/**\n\t * Attempts to get a successful response from `task` no more than `times` times\n\t * before returning an error. If the task is successful, the `callback` will be\n\t * passed the result of the successful task. If all attempts fail, the callback\n\t * will be passed the error and result (if any) of the final attempt.\n\t *\n\t * @name retry\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @see [async.retryable]{@link module:ControlFlow.retryable}\n\t * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n\t * object with `times` and `interval` or a number.\n\t * * `times` - The number of attempts to make before giving up.  The default\n\t *   is `5`.\n\t * * `interval` - The time to wait between retries, in milliseconds.  The\n\t *   default is `0`. The interval may also be specified as a function of the\n\t *   retry count (see example).\n\t * * `errorFilter` - An optional synchronous function that is invoked on\n\t *   erroneous result. If it returns `true` the retry attempts will continue;\n\t *   if the function returns `false` the retry flow is aborted with the current\n\t *   attempt's error and result being returned to the final callback.\n\t *   Invoked with (err).\n\t * * If `opts` is a number, the number specifies the number of times to retry,\n\t *   with the default interval of `0`.\n\t * @param {AsyncFunction} task - An async function to retry.\n\t * Invoked with (callback).\n\t * @param {Function} [callback] - An optional callback which is called when the\n\t * task has succeeded, or after the final failed attempt. It receives the `err`\n\t * and `result` arguments of the last attempt at completing the `task`. Invoked\n\t * with (err, results).\n\t *\n\t * @example\n\t *\n\t * // The `retry` function can be used as a stand-alone control flow by passing\n\t * // a callback, as shown below:\n\t *\n\t * // try calling apiMethod 3 times\n\t * async.retry(3, apiMethod, function(err, result) {\n\t *     // do something with the result\n\t * });\n\t *\n\t * // try calling apiMethod 3 times, waiting 200 ms between each retry\n\t * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n\t *     // do something with the result\n\t * });\n\t *\n\t * // try calling apiMethod 10 times with exponential backoff\n\t * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n\t * async.retry({\n\t *   times: 10,\n\t *   interval: function(retryCount) {\n\t *     return 50 * Math.pow(2, retryCount);\n\t *   }\n\t * }, apiMethod, function(err, result) {\n\t *     // do something with the result\n\t * });\n\t *\n\t * // try calling apiMethod the default 5 times no delay between each retry\n\t * async.retry(apiMethod, function(err, result) {\n\t *     // do something with the result\n\t * });\n\t *\n\t * // try calling apiMethod only when error condition satisfies, all other\n\t * // errors will abort the retry control flow and return to final callback\n\t * async.retry({\n\t *   errorFilter: function(err) {\n\t *     return err.message === 'Temporary error'; // only retry on a specific error\n\t *   }\n\t * }, apiMethod, function(err, result) {\n\t *     // do something with the result\n\t * });\n\t *\n\t * // It can also be embedded within other control flow functions to retry\n\t * // individual methods that are not as reliable, like this:\n\t * async.auto({\n\t *     users: api.getUsers.bind(api),\n\t *     payments: async.retryable(3, api.getPayments.bind(api))\n\t * }, function(err, results) {\n\t *     // do something with the results\n\t * });\n\t *\n\t */\n\tfunction retry(opts, task, callback) {\n\t\tvar DEFAULT_TIMES = 5;\n\t\tvar DEFAULT_INTERVAL = 0;\n\n\t\tvar options = {\n\t\t\ttimes: DEFAULT_TIMES,\n\t\t\tintervalFunc: constant$1(DEFAULT_INTERVAL)\n\t\t};\n\n\t\tfunction parseTimes(acc, t) {\n\t\t\tif (typeof t === 'object') {\n\t\t\t\tacc.times = +t.times || DEFAULT_TIMES;\n\n\t\t\t\tacc.intervalFunc = typeof t.interval === 'function' ?\n\t\t\t\t\tt.interval :\n\t\t\t\t\tconstant$1(+t.interval || DEFAULT_INTERVAL);\n\n\t\t\t\tacc.errorFilter = t.errorFilter;\n\t\t\t} else if (typeof t === 'number' || typeof t === 'string') {\n\t\t\t\tacc.times = +t || DEFAULT_TIMES;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Invalid arguments for async.retry\");\n\t\t\t}\n\t\t}\n\n\t\tif (arguments.length < 3 && typeof opts === 'function') {\n\t\t\tcallback = task || noop;\n\t\t\ttask = opts;\n\t\t} else {\n\t\t\tparseTimes(options, opts);\n\t\t\tcallback = callback || noop;\n\t\t}\n\n\t\tif (typeof task !== 'function') {\n\t\t\tthrow new Error(\"Invalid arguments for async.retry\");\n\t\t}\n\n\t\tvar _task = wrapAsync(task);\n\n\t\tvar attempt = 1;\n\t\tfunction retryAttempt() {\n\t\t\t_task(function (err) {\n\t\t\t\tif (err && attempt++ < options.times &&\n\t\t\t\t\t(typeof options.errorFilter != 'function' ||\n\t\t\t\t\t\toptions.errorFilter(err))) {\n\t\t\t\t\tsetTimeout(retryAttempt, options.intervalFunc(attempt));\n\t\t\t\t} else {\n\t\t\t\t\tcallback.apply(null, arguments);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tretryAttempt();\n\t}\n\n\t/**\n\t * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n\t * wraps a task and makes it retryable, rather than immediately calling it\n\t * with retries.\n\t *\n\t * @name retryable\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.retry]{@link module:ControlFlow.retry}\n\t * @category Control Flow\n\t * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n\t * options, exactly the same as from `retry`\n\t * @param {AsyncFunction} task - the asynchronous function to wrap.\n\t * This function will be passed any arguments passed to the returned wrapper.\n\t * Invoked with (...args, callback).\n\t * @returns {AsyncFunction} The wrapped function, which when invoked, will\n\t * retry on an error, based on the parameters specified in `opts`.\n\t * This function will accept the same parameters as `task`.\n\t * @example\n\t *\n\t * async.auto({\n\t *     dep1: async.retryable(3, getFromFlakyService),\n\t *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n\t *         maybeProcessData(results.dep1, cb);\n\t *     })]\n\t * }, callback);\n\t */\n\tvar retryable = function (opts, task) {\n\t\tif (!task) {\n\t\t\ttask = opts;\n\t\t\topts = null;\n\t\t}\n\t\tvar _task = wrapAsync(task);\n\t\treturn initialParams(function (args, callback) {\n\t\t\tfunction taskFn(cb) {\n\t\t\t\t_task.apply(null, args.concat(cb));\n\t\t\t}\n\n\t\t\tif (opts) retry(opts, taskFn, callback);\n\t\t\telse retry(taskFn, callback);\n\n\t\t});\n\t};\n\n\t/**\n\t * Run the functions in the `tasks` collection in series, each one running once\n\t * the previous function has completed. If any functions in the series pass an\n\t * error to its callback, no more functions are run, and `callback` is\n\t * immediately called with the value of the error. Otherwise, `callback`\n\t * receives an array of results when `tasks` have completed.\n\t *\n\t * It is also possible to use an object instead of an array. Each property will\n\t * be run as a function, and the results will be passed to the final `callback`\n\t * as an object instead of an array. This can be a more readable way of handling\n\t *  results from {@link async.series}.\n\t *\n\t * **Note** that while many implementations preserve the order of object\n\t * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n\t * explicitly states that\n\t *\n\t * > The mechanics and order of enumerating the properties is not specified.\n\t *\n\t * So if you rely on the order in which your series of functions are executed,\n\t * and want this to work on all platforms, consider using an array.\n\t *\n\t * @name series\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Array|Iterable|Object} tasks - A collection containing\n\t * [async functions]{@link AsyncFunction} to run in series.\n\t * Each function can complete with any number of optional `result` values.\n\t * @param {Function} [callback] - An optional callback to run once all the\n\t * functions have completed. This function gets a results array (or object)\n\t * containing all the result arguments passed to the `task` callbacks. Invoked\n\t * with (err, result).\n\t * @example\n\t * async.series([\n\t *     function(callback) {\n\t *         // do some stuff ...\n\t *         callback(null, 'one');\n\t *     },\n\t *     function(callback) {\n\t *         // do some more stuff ...\n\t *         callback(null, 'two');\n\t *     }\n\t * ],\n\t * // optional callback\n\t * function(err, results) {\n\t *     // results is now equal to ['one', 'two']\n\t * });\n\t *\n\t * async.series({\n\t *     one: function(callback) {\n\t *         setTimeout(function() {\n\t *             callback(null, 1);\n\t *         }, 200);\n\t *     },\n\t *     two: function(callback){\n\t *         setTimeout(function() {\n\t *             callback(null, 2);\n\t *         }, 100);\n\t *     }\n\t * }, function(err, results) {\n\t *     // results is now equal to: {one: 1, two: 2}\n\t * });\n\t */\n\tfunction series(tasks, callback) {\n\t\t_parallel(eachOfSeries, tasks, callback);\n\t}\n\n\t/**\n\t * Returns `true` if at least one element in the `coll` satisfies an async test.\n\t * If any iteratee call returns `true`, the main `callback` is immediately\n\t * called.\n\t *\n\t * @name some\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @alias any\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n\t * in the collections in parallel.\n\t * The iteratee should complete with a boolean `result` value.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called as soon as any\n\t * iteratee returns `true`, or after all the iteratee functions have finished.\n\t * Result will be either `true` or `false` depending on the values of the async\n\t * tests. Invoked with (err, result).\n\t * @example\n\t *\n\t * async.some(['file1','file2','file3'], function(filePath, callback) {\n\t *     fs.access(filePath, function(err) {\n\t *         callback(null, !err)\n\t *     });\n\t * }, function(err, result) {\n\t *     // if result is true then at least one of the files exists\n\t * });\n\t */\n\tvar some = doParallel(_createTester(Boolean, identity));\n\n\t/**\n\t * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n\t *\n\t * @name someLimit\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.some]{@link module:Collections.some}\n\t * @alias anyLimit\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n\t * in the collections in parallel.\n\t * The iteratee should complete with a boolean `result` value.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called as soon as any\n\t * iteratee returns `true`, or after all the iteratee functions have finished.\n\t * Result will be either `true` or `false` depending on the values of the async\n\t * tests. Invoked with (err, result).\n\t */\n\tvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n\t/**\n\t * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n\t *\n\t * @name someSeries\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @see [async.some]{@link module:Collections.some}\n\t * @alias anySeries\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n\t * in the collections in series.\n\t * The iteratee should complete with a boolean `result` value.\n\t * Invoked with (item, callback).\n\t * @param {Function} [callback] - A callback which is called as soon as any\n\t * iteratee returns `true`, or after all the iteratee functions have finished.\n\t * Result will be either `true` or `false` depending on the values of the async\n\t * tests. Invoked with (err, result).\n\t */\n\tvar someSeries = doLimit(someLimit, 1);\n\n\t/**\n\t * Sorts a list by the results of running each `coll` value through an async\n\t * `iteratee`.\n\t *\n\t * @name sortBy\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {AsyncFunction} iteratee - An async function to apply to each item in\n\t * `coll`.\n\t * The iteratee should complete with a value to use as the sort criteria as\n\t * its `result`.\n\t * Invoked with (item, callback).\n\t * @param {Function} callback - A callback which is called after all the\n\t * `iteratee` functions have finished, or an error occurs. Results is the items\n\t * from the original `coll` sorted by the values returned by the `iteratee`\n\t * calls. Invoked with (err, results).\n\t * @example\n\t *\n\t * async.sortBy(['file1','file2','file3'], function(file, callback) {\n\t *     fs.stat(file, function(err, stats) {\n\t *         callback(err, stats.mtime);\n\t *     });\n\t * }, function(err, results) {\n\t *     // results is now the original array of files sorted by\n\t *     // modified date\n\t * });\n\t *\n\t * // By modifying the callback parameter the\n\t * // sorting order can be influenced:\n\t *\n\t * // ascending order\n\t * async.sortBy([1,9,3,5], function(x, callback) {\n\t *     callback(null, x);\n\t * }, function(err,result) {\n\t *     // result callback\n\t * });\n\t *\n\t * // descending order\n\t * async.sortBy([1,9,3,5], function(x, callback) {\n\t *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n\t * }, function(err,result) {\n\t *     // result callback\n\t * });\n\t */\n\tfunction sortBy(coll, iteratee, callback) {\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\tmap(coll, function (x, callback) {\n\t\t\t_iteratee(x, function (err, criteria) {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tcallback(null, { value: x, criteria: criteria });\n\t\t\t});\n\t\t}, function (err, results) {\n\t\t\tif (err) return callback(err);\n\t\t\tcallback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n\t\t});\n\n\t\tfunction comparator(left, right) {\n\t\t\tvar a = left.criteria, b = right.criteria;\n\t\t\treturn a < b ? -1 : a > b ? 1 : 0;\n\t\t}\n\t}\n\n\t/**\n\t * Sets a time limit on an asynchronous function. If the function does not call\n\t * its callback within the specified milliseconds, it will be called with a\n\t * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n\t *\n\t * @name timeout\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @category Util\n\t * @param {AsyncFunction} asyncFn - The async function to limit in time.\n\t * @param {number} milliseconds - The specified time limit.\n\t * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n\t * to timeout Error for more information..\n\t * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n\t * of the control flow functions.\n\t * Invoke this function with the same parameters as you would `asyncFunc`.\n\t * @example\n\t *\n\t * function myFunction(foo, callback) {\n\t *     doAsyncTask(foo, function(err, data) {\n\t *         // handle errors\n\t *         if (err) return callback(err);\n\t *\n\t *         // do some stuff ...\n\t *\n\t *         // return processed data\n\t *         return callback(null, data);\n\t *     });\n\t * }\n\t *\n\t * var wrapped = async.timeout(myFunction, 1000);\n\t *\n\t * // call `wrapped` as you would `myFunction`\n\t * wrapped({ bar: 'bar' }, function(err, data) {\n\t *     // if `myFunction` takes < 1000 ms to execute, `err`\n\t *     // and `data` will have their expected values\n\t *\n\t *     // else `err` will be an Error with the code 'ETIMEDOUT'\n\t * });\n\t */\n\tfunction timeout(asyncFn, milliseconds, info) {\n\t\tvar originalCallback, timer;\n\t\tvar timedOut = false;\n\n\t\tfunction injectedCallback() {\n\t\t\tif (!timedOut) {\n\t\t\t\toriginalCallback.apply(null, arguments);\n\t\t\t\tclearTimeout(timer);\n\t\t\t}\n\t\t}\n\n\t\tfunction timeoutCallback() {\n\t\t\tvar name = asyncFn.name || 'anonymous';\n\t\t\tvar error = new Error('Callback function \"' + name + '\" timed out.');\n\t\t\terror.code = 'ETIMEDOUT';\n\t\t\tif (info) {\n\t\t\t\terror.info = info;\n\t\t\t}\n\t\t\ttimedOut = true;\n\t\t\toriginalCallback(error);\n\t\t}\n\n\t\tvar fn = wrapAsync(asyncFn);\n\n\t\treturn initialParams(function (args, origCallback) {\n\t\t\toriginalCallback = origCallback;\n\t\t\t// setup timer and call original function\n\t\t\ttimer = setTimeout(timeoutCallback, milliseconds);\n\t\t\tfn.apply(null, args.concat(injectedCallback));\n\t\t});\n\t}\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeCeil = Math.ceil;\n\tvar nativeMax = Math.max;\n\n\t/**\n\t * The base implementation of `_.range` and `_.rangeRight` which doesn't\n\t * coerce arguments.\n\t *\n\t * @private\n\t * @param {number} start The start of the range.\n\t * @param {number} end The end of the range.\n\t * @param {number} step The value to increment or decrement by.\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Array} Returns the range of numbers.\n\t */\n\tfunction baseRange(start, end, step, fromRight) {\n\t\tvar index = -1,\n\t\t\tlength = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n\t\t\tresult = Array(length);\n\n\t\twhile (length--) {\n\t\t\tresult[fromRight ? length : ++index] = start;\n\t\t\tstart += step;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n\t * time.\n\t *\n\t * @name timesLimit\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.times]{@link module:ControlFlow.times}\n\t * @category Control Flow\n\t * @param {number} count - The number of times to run the function.\n\t * @param {number} limit - The maximum number of async operations at a time.\n\t * @param {AsyncFunction} iteratee - The async function to call `n` times.\n\t * Invoked with the iteration index and a callback: (n, next).\n\t * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n\t */\n\tfunction timeLimit(count, limit, iteratee, callback) {\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\tmapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n\t}\n\n\t/**\n\t * Calls the `iteratee` function `n` times, and accumulates results in the same\n\t * manner you would use with [map]{@link module:Collections.map}.\n\t *\n\t * @name times\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.map]{@link module:Collections.map}\n\t * @category Control Flow\n\t * @param {number} n - The number of times to run the function.\n\t * @param {AsyncFunction} iteratee - The async function to call `n` times.\n\t * Invoked with the iteration index and a callback: (n, next).\n\t * @param {Function} callback - see {@link module:Collections.map}.\n\t * @example\n\t *\n\t * // Pretend this is some complicated async factory\n\t * var createUser = function(id, callback) {\n\t *     callback(null, {\n\t *         id: 'user' + id\n\t *     });\n\t * };\n\t *\n\t * // generate 5 users\n\t * async.times(5, function(n, next) {\n\t *     createUser(n, function(err, user) {\n\t *         next(err, user);\n\t *     });\n\t * }, function(err, users) {\n\t *     // we should now have 5 users\n\t * });\n\t */\n\tvar times = doLimit(timeLimit, Infinity);\n\n\t/**\n\t * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n\t *\n\t * @name timesSeries\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.times]{@link module:ControlFlow.times}\n\t * @category Control Flow\n\t * @param {number} n - The number of times to run the function.\n\t * @param {AsyncFunction} iteratee - The async function to call `n` times.\n\t * Invoked with the iteration index and a callback: (n, next).\n\t * @param {Function} callback - see {@link module:Collections.map}.\n\t */\n\tvar timesSeries = doLimit(timeLimit, 1);\n\n\t/**\n\t * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n\t * element in series, each step potentially mutating an `accumulator` value.\n\t * The type of the accumulator defaults to the type of collection passed in.\n\t *\n\t * @name transform\n\t * @static\n\t * @memberOf module:Collections\n\t * @method\n\t * @category Collection\n\t * @param {Array|Iterable|Object} coll - A collection to iterate over.\n\t * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n\t * it will default to an empty Object or Array, depending on the type of `coll`\n\t * @param {AsyncFunction} iteratee - A function applied to each item in the\n\t * collection that potentially modifies the accumulator.\n\t * Invoked with (accumulator, item, key, callback).\n\t * @param {Function} [callback] - A callback which is called after all the\n\t * `iteratee` functions have finished. Result is the transformed accumulator.\n\t * Invoked with (err, result).\n\t * @example\n\t *\n\t * async.transform([1,2,3], function(acc, item, index, callback) {\n\t *     // pointless async:\n\t *     process.nextTick(function() {\n\t *         acc.push(item * 2)\n\t *         callback(null)\n\t *     });\n\t * }, function(err, result) {\n\t *     // result is now equal to [2, 4, 6]\n\t * });\n\t *\n\t * @example\n\t *\n\t * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n\t *     setImmediate(function () {\n\t *         obj[key] = val * 2;\n\t *         callback();\n\t *     })\n\t * }, function (err, result) {\n\t *     // result is equal to {a: 2, b: 4, c: 6}\n\t * })\n\t */\n\tfunction transform(coll, accumulator, iteratee, callback) {\n\t\tif (arguments.length <= 3) {\n\t\t\tcallback = iteratee;\n\t\t\titeratee = accumulator;\n\t\t\taccumulator = isArray(coll) ? [] : {};\n\t\t}\n\t\tcallback = once(callback || noop);\n\t\tvar _iteratee = wrapAsync(iteratee);\n\n\t\teachOf(coll, function (v, k, cb) {\n\t\t\t_iteratee(accumulator, v, k, cb);\n\t\t}, function (err) {\n\t\t\tcallback(err, accumulator);\n\t\t});\n\t}\n\n\t/**\n\t * It runs each task in series but stops whenever any of the functions were\n\t * successful. If one of the tasks were successful, the `callback` will be\n\t * passed the result of the successful task. If all tasks fail, the callback\n\t * will be passed the error and result (if any) of the final attempt.\n\t *\n\t * @name tryEach\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Array|Iterable|Object} tasks - A collection containing functions to\n\t * run, each function is passed a `callback(err, result)` it must call on\n\t * completion with an error `err` (which can be `null`) and an optional `result`\n\t * value.\n\t * @param {Function} [callback] - An optional callback which is called when one\n\t * of the tasks has succeeded, or all have failed. It receives the `err` and\n\t * `result` arguments of the last attempt at completing the `task`. Invoked with\n\t * (err, results).\n\t * @example\n\t * async.try([\n\t *     function getDataFromFirstWebsite(callback) {\n\t *         // Try getting the data from the first website\n\t *         callback(err, data);\n\t *     },\n\t *     function getDataFromSecondWebsite(callback) {\n\t *         // First website failed,\n\t *         // Try getting the data from the backup website\n\t *         callback(err, data);\n\t *     }\n\t * ],\n\t * // optional callback\n\t * function(err, results) {\n\t *     Now do something with the data.\n\t * });\n\t *\n\t */\n\tfunction tryEach(tasks, callback) {\n\t\tvar error = null;\n\t\tvar result;\n\t\tcallback = callback || noop;\n\t\teachSeries(tasks, function (task, callback) {\n\t\t\twrapAsync(task)(function (err, res/*, ...args*/) {\n\t\t\t\tif (arguments.length > 2) {\n\t\t\t\t\tresult = slice(arguments, 1);\n\t\t\t\t} else {\n\t\t\t\t\tresult = res;\n\t\t\t\t}\n\t\t\t\terror = err;\n\t\t\t\tcallback(!err);\n\t\t\t});\n\t\t}, function () {\n\t\t\tcallback(error, result);\n\t\t});\n\t}\n\n\t/**\n\t * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n\t * unmemoized form. Handy for testing.\n\t *\n\t * @name unmemoize\n\t * @static\n\t * @memberOf module:Utils\n\t * @method\n\t * @see [async.memoize]{@link module:Utils.memoize}\n\t * @category Util\n\t * @param {AsyncFunction} fn - the memoized function\n\t * @returns {AsyncFunction} a function that calls the original unmemoized function\n\t */\n\tfunction unmemoize(fn) {\n\t\treturn function () {\n\t\t\treturn (fn.unmemoized || fn).apply(null, arguments);\n\t\t};\n\t}\n\n\t/**\n\t * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n\t * stopped, or an error occurs.\n\t *\n\t * @name whilst\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Function} test - synchronous truth test to perform before each\n\t * execution of `iteratee`. Invoked with ().\n\t * @param {AsyncFunction} iteratee - An async function which is called each time\n\t * `test` passes. Invoked with (callback).\n\t * @param {Function} [callback] - A callback which is called after the test\n\t * function has failed and repeated execution of `iteratee` has stopped. `callback`\n\t * will be passed an error and any arguments passed to the final `iteratee`'s\n\t * callback. Invoked with (err, [results]);\n\t * @returns undefined\n\t * @example\n\t *\n\t * var count = 0;\n\t * async.whilst(\n\t *     function() { return count < 5; },\n\t *     function(callback) {\n\t *         count++;\n\t *         setTimeout(function() {\n\t *             callback(null, count);\n\t *         }, 1000);\n\t *     },\n\t *     function (err, n) {\n\t *         // 5 seconds have passed, n = 5\n\t *     }\n\t * );\n\t */\n\tfunction whilst(test, iteratee, callback) {\n\t\tcallback = onlyOnce(callback || noop);\n\t\tvar _iteratee = wrapAsync(iteratee);\n\t\tif (!test()) return callback(null);\n\t\tvar next = function (err/*, ...args*/) {\n\t\t\tif (err) return callback(err);\n\t\t\tif (test()) return _iteratee(next);\n\t\t\tvar args = slice(arguments, 1);\n\t\t\tcallback.apply(null, [null].concat(args));\n\t\t};\n\t\t_iteratee(next);\n\t}\n\n\t/**\n\t * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n\t * stopped, or an error occurs. `callback` will be passed an error and any\n\t * arguments passed to the final `iteratee`'s callback.\n\t *\n\t * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n\t *\n\t * @name until\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @see [async.whilst]{@link module:ControlFlow.whilst}\n\t * @category Control Flow\n\t * @param {Function} test - synchronous truth test to perform before each\n\t * execution of `iteratee`. Invoked with ().\n\t * @param {AsyncFunction} iteratee - An async function which is called each time\n\t * `test` fails. Invoked with (callback).\n\t * @param {Function} [callback] - A callback which is called after the test\n\t * function has passed and repeated execution of `iteratee` has stopped. `callback`\n\t * will be passed an error and any arguments passed to the final `iteratee`'s\n\t * callback. Invoked with (err, [results]);\n\t */\n\tfunction until(test, iteratee, callback) {\n\t\twhilst(function () {\n\t\t\treturn !test.apply(this, arguments);\n\t\t}, iteratee, callback);\n\t}\n\n\t/**\n\t * Runs the `tasks` array of functions in series, each passing their results to\n\t * the next in the array. However, if any of the `tasks` pass an error to their\n\t * own callback, the next function is not executed, and the main `callback` is\n\t * immediately called with the error.\n\t *\n\t * @name waterfall\n\t * @static\n\t * @memberOf module:ControlFlow\n\t * @method\n\t * @category Control Flow\n\t * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n\t * to run.\n\t * Each function should complete with any number of `result` values.\n\t * The `result` values will be passed as arguments, in order, to the next task.\n\t * @param {Function} [callback] - An optional callback to run once all the\n\t * functions have completed. This will be passed the results of the last task's\n\t * callback. Invoked with (err, [results]).\n\t * @returns undefined\n\t * @example\n\t *\n\t * async.waterfall([\n\t *     function(callback) {\n\t *         callback(null, 'one', 'two');\n\t *     },\n\t *     function(arg1, arg2, callback) {\n\t *         // arg1 now equals 'one' and arg2 now equals 'two'\n\t *         callback(null, 'three');\n\t *     },\n\t *     function(arg1, callback) {\n\t *         // arg1 now equals 'three'\n\t *         callback(null, 'done');\n\t *     }\n\t * ], function (err, result) {\n\t *     // result now equals 'done'\n\t * });\n\t *\n\t * // Or, with named functions:\n\t * async.waterfall([\n\t *     myFirstFunction,\n\t *     mySecondFunction,\n\t *     myLastFunction,\n\t * ], function (err, result) {\n\t *     // result now equals 'done'\n\t * });\n\t * function myFirstFunction(callback) {\n\t *     callback(null, 'one', 'two');\n\t * }\n\t * function mySecondFunction(arg1, arg2, callback) {\n\t *     // arg1 now equals 'one' and arg2 now equals 'two'\n\t *     callback(null, 'three');\n\t * }\n\t * function myLastFunction(arg1, callback) {\n\t *     // arg1 now equals 'three'\n\t *     callback(null, 'done');\n\t * }\n\t */\n\tvar waterfall = function (tasks, callback) {\n\t\tcallback = once(callback || noop);\n\t\tif (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n\t\tif (!tasks.length) return callback();\n\t\tvar taskIndex = 0;\n\n\t\tfunction nextTask(args) {\n\t\t\tvar task = wrapAsync(tasks[taskIndex++]);\n\t\t\targs.push(onlyOnce(next));\n\t\t\ttask.apply(null, args);\n\t\t}\n\n\t\tfunction next(err/*, ...args*/) {\n\t\t\tif (err || taskIndex === tasks.length) {\n\t\t\t\treturn callback.apply(null, arguments);\n\t\t\t}\n\t\t\tnextTask(slice(arguments, 1));\n\t\t}\n\n\t\tnextTask([]);\n\t};\n\n\t/**\n\t * An \"async function\" in the context of Async is an asynchronous function with\n\t * a variable number of parameters, with the final parameter being a callback.\n\t * (`function (arg1, arg2, ..., callback) {}`)\n\t * The final callback is of the form `callback(err, results...)`, which must be\n\t * called once the function is completed.  The callback should be called with a\n\t * Error as its first argument to signal that an error occurred.\n\t * Otherwise, if no error occurred, it should be called with `null` as the first\n\t * argument, and any additional `result` arguments that may apply, to signal\n\t * successful completion.\n\t * The callback must be called exactly once, ideally on a later tick of the\n\t * JavaScript event loop.\n\t *\n\t * This type of function is also referred to as a \"Node-style async function\",\n\t * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n\t * library are themselves CPS/Node-style async functions, or functions that\n\t * return CPS/Node-style async functions.\n\t *\n\t * Wherever we accept a Node-style async function, we also directly accept an\n\t * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n\t * In this case, the `async` function will not be passed a final callback\n\t * argument, and any thrown error will be used as the `err` argument of the\n\t * implicit callback, and the return value will be used as the `result` value.\n\t * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n\t * argument, and a `resolved` value becomes the `result`.)\n\t *\n\t * Note, due to JavaScript limitations, we can only detect native `async`\n\t * functions and not transpilied implementations.\n\t * Your environment must have `async`/`await` support for this to work.\n\t * (e.g. Node > v7.6, or a recent version of a modern browser).\n\t * If you are using `async` functions through a transpiler (e.g. Babel), you\n\t * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n\t * because the `async function` will be compiled to an ordinary function that\n\t * returns a promise.\n\t *\n\t * @typedef {Function} AsyncFunction\n\t * @static\n\t */\n\n\t/**\n\t * Async is a utility module which provides straight-forward, powerful functions\n\t * for working with asynchronous JavaScript. Although originally designed for\n\t * use with [Node.js](http://nodejs.org) and installable via\n\t * `npm install --save async`, it can also be used directly in the browser.\n\t * @module async\n\t * @see AsyncFunction\n\t */\n\n\n\t/**\n\t * A collection of `async` functions for manipulating collections, such as\n\t * arrays and objects.\n\t * @module Collections\n\t */\n\n\t/**\n\t * A collection of `async` functions for controlling the flow through a script.\n\t * @module ControlFlow\n\t */\n\n\t/**\n\t * A collection of `async` utility functions.\n\t * @module Utils\n\t */\n\n\tvar index = {\n\t\tapplyEach: applyEach,\n\t\tapplyEachSeries: applyEachSeries,\n\t\tapply: apply,\n\t\tasyncify: asyncify,\n\t\tauto: auto,\n\t\tautoInject: autoInject,\n\t\tcargo: cargo,\n\t\tcompose: compose,\n\t\tconcat: concat,\n\t\tconcatSeries: concatSeries,\n\t\tconstant: constant,\n\t\tdetect: detect,\n\t\tdetectLimit: detectLimit,\n\t\tdetectSeries: detectSeries,\n\t\tdir: dir,\n\t\tdoDuring: doDuring,\n\t\tdoUntil: doUntil,\n\t\tdoWhilst: doWhilst,\n\t\tduring: during,\n\t\teach: eachLimit,\n\t\teachLimit: eachLimit$1,\n\t\teachOf: eachOf,\n\t\teachOfLimit: eachOfLimit,\n\t\teachOfSeries: eachOfSeries,\n\t\teachSeries: eachSeries,\n\t\tensureAsync: ensureAsync,\n\t\tevery: every,\n\t\teveryLimit: everyLimit,\n\t\teverySeries: everySeries,\n\t\tfilter: filter,\n\t\tfilterLimit: filterLimit,\n\t\tfilterSeries: filterSeries,\n\t\tforever: forever,\n\t\tgroupBy: groupBy,\n\t\tgroupByLimit: groupByLimit,\n\t\tgroupBySeries: groupBySeries,\n\t\tlog: log,\n\t\tmap: map,\n\t\tmapLimit: mapLimit,\n\t\tmapSeries: mapSeries,\n\t\tmapValues: mapValues,\n\t\tmapValuesLimit: mapValuesLimit,\n\t\tmapValuesSeries: mapValuesSeries,\n\t\tmemoize: memoize,\n\t\tnextTick: nextTick,\n\t\tparallel: parallelLimit,\n\t\tparallelLimit: parallelLimit$1,\n\t\tpriorityQueue: priorityQueue,\n\t\tqueue: queue$1,\n\t\trace: race,\n\t\treduce: reduce,\n\t\treduceRight: reduceRight,\n\t\treflect: reflect,\n\t\treflectAll: reflectAll,\n\t\treject: reject,\n\t\trejectLimit: rejectLimit,\n\t\trejectSeries: rejectSeries,\n\t\tretry: retry,\n\t\tretryable: retryable,\n\t\tseq: seq,\n\t\tseries: series,\n\t\tsetImmediate: setImmediate$1,\n\t\tsome: some,\n\t\tsomeLimit: someLimit,\n\t\tsomeSeries: someSeries,\n\t\tsortBy: sortBy,\n\t\ttimeout: timeout,\n\t\ttimes: times,\n\t\ttimesLimit: timeLimit,\n\t\ttimesSeries: timesSeries,\n\t\ttransform: transform,\n\t\ttryEach: tryEach,\n\t\tunmemoize: unmemoize,\n\t\tuntil: until,\n\t\twaterfall: waterfall,\n\t\twhilst: whilst,\n\n\t\t// aliases\n\t\tall: every,\n\t\tany: some,\n\t\tforEach: eachLimit,\n\t\tforEachSeries: eachSeries,\n\t\tforEachLimit: eachLimit$1,\n\t\tforEachOf: eachOf,\n\t\tforEachOfSeries: eachOfSeries,\n\t\tforEachOfLimit: eachOfLimit,\n\t\tinject: reduce,\n\t\tfoldl: reduce,\n\t\tfoldr: reduceRight,\n\t\tselect: filter,\n\t\tselectLimit: filterLimit,\n\t\tselectSeries: filterSeries,\n\t\twrapSync: asyncify\n\t};\n\n\texports['default'] = index;\n\texports.applyEach = applyEach;\n\texports.applyEachSeries = applyEachSeries;\n\texports.apply = apply;\n\texports.asyncify = asyncify;\n\texports.auto = auto;\n\texports.autoInject = autoInject;\n\texports.cargo = cargo;\n\texports.compose = compose;\n\texports.concat = concat;\n\texports.concatSeries = concatSeries;\n\texports.constant = constant;\n\texports.detect = detect;\n\texports.detectLimit = detectLimit;\n\texports.detectSeries = detectSeries;\n\texports.dir = dir;\n\texports.doDuring = doDuring;\n\texports.doUntil = doUntil;\n\texports.doWhilst = doWhilst;\n\texports.during = during;\n\texports.each = eachLimit;\n\texports.eachLimit = eachLimit$1;\n\texports.eachOf = eachOf;\n\texports.eachOfLimit = eachOfLimit;\n\texports.eachOfSeries = eachOfSeries;\n\texports.eachSeries = eachSeries;\n\texports.ensureAsync = ensureAsync;\n\texports.every = every;\n\texports.everyLimit = everyLimit;\n\texports.everySeries = everySeries;\n\texports.filter = filter;\n\texports.filterLimit = filterLimit;\n\texports.filterSeries = filterSeries;\n\texports.forever = forever;\n\texports.groupBy = groupBy;\n\texports.groupByLimit = groupByLimit;\n\texports.groupBySeries = groupBySeries;\n\texports.log = log;\n\texports.map = map;\n\texports.mapLimit = mapLimit;\n\texports.mapSeries = mapSeries;\n\texports.mapValues = mapValues;\n\texports.mapValuesLimit = mapValuesLimit;\n\texports.mapValuesSeries = mapValuesSeries;\n\texports.memoize = memoize;\n\texports.nextTick = nextTick;\n\texports.parallel = parallelLimit;\n\texports.parallelLimit = parallelLimit$1;\n\texports.priorityQueue = priorityQueue;\n\texports.queue = queue$1;\n\texports.race = race;\n\texports.reduce = reduce;\n\texports.reduceRight = reduceRight;\n\texports.reflect = reflect;\n\texports.reflectAll = reflectAll;\n\texports.reject = reject;\n\texports.rejectLimit = rejectLimit;\n\texports.rejectSeries = rejectSeries;\n\texports.retry = retry;\n\texports.retryable = retryable;\n\texports.seq = seq;\n\texports.series = series;\n\texports.setImmediate = setImmediate$1;\n\texports.some = some;\n\texports.someLimit = someLimit;\n\texports.someSeries = someSeries;\n\texports.sortBy = sortBy;\n\texports.timeout = timeout;\n\texports.times = times;\n\texports.timesLimit = timeLimit;\n\texports.timesSeries = timesSeries;\n\texports.transform = transform;\n\texports.tryEach = tryEach;\n\texports.unmemoize = unmemoize;\n\texports.until = until;\n\texports.waterfall = waterfall;\n\texports.whilst = whilst;\n\texports.all = every;\n\texports.allLimit = everyLimit;\n\texports.allSeries = everySeries;\n\texports.any = some;\n\texports.anyLimit = someLimit;\n\texports.anySeries = someSeries;\n\texports.find = detect;\n\texports.findLimit = detectLimit;\n\texports.findSeries = detectSeries;\n\texports.forEach = eachLimit;\n\texports.forEachSeries = eachSeries;\n\texports.forEachLimit = eachLimit$1;\n\texports.forEachOf = eachOf;\n\texports.forEachOfSeries = eachOfSeries;\n\texports.forEachOfLimit = eachOfLimit;\n\texports.inject = reduce;\n\texports.foldl = reduce;\n\texports.foldr = reduceRight;\n\texports.select = filter;\n\texports.selectLimit = filterLimit;\n\texports.selectSeries = filterSeries;\n\texports.wrapSync = asyncify;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));",
  "icon.png": "PNG\r\n\u001a\n\u0000\u0000\u0000\rIHDR\u0000\u0000\u0000\u0000\u0000\u0000\b\u0006\u0000\u0000\u0000>a\u0000\u0000JIDATx\u0007T\u0014>=y\u0019`\f9,\u00103 %+F@s\u0002\u0012\u0004\u0004Ey\r\u0006n]\u0003yar_\r\tD{Q{z\rUoUkC-0\u001f\u0001\u0011`\u0010P\u001f;\u001e\u001djY^\u0016#ku,O=\"q\u0013e?\u0002&DqpvBE\\*?~\b8\u00172Nxxl`dkkE\u0000oO#\u000f>}{ZSPC\u001cg\u001b\u001ejy^\u0005o\u001d\u0001j\u0014\u0003ax##cL(P\u001f6T\u0007\nczZW[G\u0000=\u001d=C\u000f\u000e\u000bsc+Z$P'{zh\u001d-_K\"\u0019j^\u0005o%\u00016\u001f1\u000e\t5\u0002\u0015J\bm\u001fjy5M^\f\u0017T2'r\u0017$F=J\u0002\u001ch@xOwOw2HP4\u001f\u000e\u001c=Ii\u001f\f<\u0000z-\f\n\u001e3\bEY\u001ajy\u001eGK\u0004T^\u001f\u0014\u0003\u0004IcezU\u0004]dm`a3,l</y*ezL@VK\u000bs\u001c#\u001fj^\u0015o-\u0001/\u0007lo\r\u001e5A.\u00199P\u0010\u001b+z\u001c\u001b*e?M8jP:xk\t#,|rLtX\u0014-\u001bj\u000e]\u0002z/x(+1cZ[ML6d\b\u000b\t~Z't\u0006.N\u001aQgkuV\u0013@\r\u0007\u000es\u000b\u001a6B)gy>[X&\fu.z\u0002T\u001e;mb>\u000b\f4\u0012u,\u0010P1CU\u001c\u0019S'n\u001fy]\u0004cbca43l>E(\u0018O'\u001a\u001aZXX\u0005yq\ru.+\bPTw\u0007\u001d\u0012~|j>o1aN\u0017\"Fn\u0006\u0014\u0003\u0018Z\u0004AQ\u0002\u0001\u000fB$@! \u001e\u000f\u001c\u00148:bJ!\u0017(%?P\u0016\u0001!\r1}n+\u0004Z1~\u0018D\u0017\bI\u0011\u0004*m\u0018J\"\u0010\b\u000e2\u0014\n\u0004p<`3\u001e_0G\u0012{J,\u0015D\u0002oe sWp<3g/@\f\u0016\u0003k4Z\f\u000e\u00021\b\u0000\u000eh\u0010Z#TVA\nZ\u0002\u0016pD!(#\u0014Ja\u0018R\bhB`<\u000fK y\u0010$\u0013\"\fqx\u0018\u0001]\\T2C+\u0013}hp8$\n\u0013\u000b\f\r{c\bh\u0007\u0010*'^9u V.^cL7'\u0015p\u0010.\u0004\u0012H$\u0012H$X\u001c\u000eb00?\u001f\u0007h,\r6@\u0011\u0014h4ZU\nX-F_ <\u001b,\u0011'](S4hjFck\u001d*V2tU\u0013N\nNN?{(/du9&FCT\n\u0013VgA G\u0014X%\"S\u0002`\u0006cq\u001a\u0004b\u0006\\\u0003\u001a\u001f\u0005i\rZM'\tXL~\u00076W\u001c\u001a\u0010\t|7}Qk,q^kiigG\u001ezY\u00048t2#\u0010~\u0017\u0018!qoARN03\u0011cIU,kKk\u000e\t\b:7Kj\\BFS\"\u0000k\u001a9x\u001c^V_niSoZ\u0013\u000er\u001c\u0017z/t~jUb2\u0003\u0018\u0012eOWj?\u0004<~U#lcooh(#qzi}\u0004&Ou$\u00003pMv_=Lj\u0015\\S+OCdq\r\u001c\u0016oH3*zRg'LP@V\u0012%@\"{9VD\u0016'>*N\u001a7\u001dR?\u001c?bgmqq\t\u001aAO)\u0013\nWFO.fKd@\u00025\u0013w._\u0000(rr]\u001cX005\u001f9\u0016\n\u0019~\n\u001fKe\u0003H\u001f\u001cb,dvO~.\u0010\r\u000eAFF\u001a9sv\u001d%\u001b=f@)jo\u001d\u0001J\u0018gh\u0016_tUFP\u000bM\"f)yWG\u00198\\0\u0000og\u000b\u000e&kNY:sYt\rG$\u0010.\u0002\u00184':$x\bP|Mo`\u0018\u000b\u001d\u0017g$lC\r6\u0017,\u0015)Oj9\u001c A\u0010\u0006\u001b\u001d=\u0010\u0019\u0013GM\u001a3vVSllm\t*\\!n\u0007M[\brEU)Z)\u0011\u00035}k\bPq\nsp\u0016uw\\cO9[e\\g\u000faY]uj\u001aD`y\u0010kZ]\u0004'D\rHT\u001d\nFFMLzR*\u001dq~<\u0016O@h\u001ca\u0014a:\u000494eP\"3b$\u0012-jaa)Q*2\\.\u0019;!\u0000\u0007O]\f{g1}\u0003'\u0014peK]1\u0018\u0018R5\u0010d%VujTV\rh[\b\u0002\u0014FQ)\u0004R\u0018\u0011a1\u0018V\u0005\r<\f\u0011\b\u0014\u0003O\u0002\u0002\u001aB(\u0017\t~UU\u0012Q\u001bI[\u0012o_\u001fH\u0019\u0017?@yX$<hdjb\n)TR/_Pp\u0018EK \u0012\"6\u001bA\u0011f~BKK\f9\u0001@O*4,\u001d\\\"$|^\u000b^\u001e\u001a@*QOs+\t\u001dwU\nY\u001b\u0006O'R(\u000ex\"\u0012G0X\u001c\u00064:y\u0007|~PX?UjK'Bt@']>+7sCq\nb\u0012\u0006O:CO]y\"\u000e;<?9esW\f-VnP\u001e.7yyNw\"8&\u0000z\u001e=@X\u001a*?\u00048xRd<\\$\u0014\b`ptaVz'\u001c7>[R.;h~Jlo\u000f(ol&Zc\u001d\u0002\u0012`:\u0004\"a\u0018\u0014\u0013BF$QS}cMqA\\_<;>jH\t\u000b\u0013x/%Z\n8=\u001bl\u001d1lHX\fP9'5*EQ_ti\u0019\u000f\u0015)qv\u0012\b0E\u0010(\u0011e\u000f\u0018a$z\u0010\u0011'io\u0007r#4{\u0018N!\u0015c)|}h\u000f\u0000Ly\t\u0013\u000eO(HU\u000f\u0019;41Q)LOxE+Eu=ERns\u0007\u0004K+K%x\u0017)Iky\u0017\bi\u0016dsK\u000b)\\\u0019#\u001b|\u00177V$=\u0000\\{g`\u0018-x\u0017<\u000fSqtF\rFtI\u000bZ\u0007Ty'-XM:X\u0017OO\u0016+<72\"\r?19<j0dZY7<#`-HT=msvG-L~8@\u0013p_\u001dj\u001aU\u001ad$\u000bKK``D-\u0011~R(*P\u0004(71RWv\\\n3mx\\NWb39\u0010E\u0000\f \u0000jhS+\u0015XR)H~?/TjN\u0003Sd\n\u0019#bua9\u000f(\u0019P*l1Y\u001a$;;GG\u0011Mrpt@\u0003R]Yh\u001d5vN?53f|3=Ewh4\n\u000b_'x\u001c{\u001c\u000f+cmQ<\u001e\u0007kd?z:\u0019N\u0000L`gs\fZ\u0002J&(D2 (J\u000bx8LNaJ+\u0015yalmZA\\\u000e}X\u001c=`\rf3\u0007m\u001aA%ac\u00053c&J<u\u0001\u0002\u0018\u0002fgS+\u0007x1;;[{\u0012 Awc\u0012t\u00116\u000e\"H :$\u001cy\t_\u000f\u0000\u0007N^J\nc#3`y,,M%K\u000b4iS[\u0007\u0002\u0012r\n\"t\tYtC\u0012%kc\u00161\n;:\u0014\\>#\tl+J3v<cia.t&\r!F(\u000e)}s>@K\\tqs')8uJW'/\u001aHK@$x\u0015\u001adNqod@`w\rR\u0005\fV@#A\bu\u0005-H\\\u001akLm|\n\u0003-\\yk\u001a\u0018[^\"\u0011|i\u0017\b\u001d=#F9\u0003\u0007iI;_R6\u001e\u001f\u0005S13r\u0017/n8i&jm}\t;bAF7/Sj\u0018w\r'@K\u001c\tXpQK_[^\u00020+\u0013\u0019cLA|m*\u0017:4\n1_?,W}=sHfm7F3\n<\u0001*Xve\u0005{/\u0018x\fUHG.NYlS@~C\np[RKxF*aHs\u0013\u0006z\u0003UX#R;ggsD\"<I\u0015f&re*_$A]hnnB`\u001eWy\u0018Po\u0007\u0001\u001eN\"O7P.Ue2\u000eK04Q8qw9\u0002tajK\u0003GcMB(je\u00153SwTe:%p0#\u0011AT\u000f8\u0018D\bdOhZ\u0014P\f\u000e\u0017I\u001ahD\u0002\u0011\"sdy/#3f\u0002x-a[`ii\u0005kEfHOOL=6PC:@\u00187\u001c\u000e]\u001ft\u0005)S;V*)\r\u0010\u0000\rhpY8@II'L6n\u0015\u0002FJ\u0004N,\u001et23_iG-l\u000fjvRdV\u0006V\u0017W}\u0015\u00146a'P\nhxoV`!T@\u0018+\bGp\u0011\b\u0014\"{R\"\u0004O)h*'1ip\u0016\u0015M\u001d\\RaTt\u0011\u0005)^O\u0013\\\n-RDv@\u0019$]dO\u0015X.kn>0(\u0003A\\x\u0002rKg\f3s3<|\\,K+y1\u0003\u0000\bx\f9 \u00103L\u001b\u0000\u001b\u001d=I$JZea\u0018@\"\u0018\u001az\u000f\u0003:\u0004U\u0006QJ\u001f(|Efm\t\u001c=6~+j\bLN:3?=\u000e7y\u0000Gz\u0015,\u000bkkN.`888Hz\u000f4CA~R\u00136FD5G2\u0004xGNbx<\u001e\u0010\tT{@;2Y@U7R\u000e}\u0014<n+\u001b\u0006D\u001bw0l\u001do^6u\u000fQgq\u001an0D1\u0001yAQ\fO\u0012P\u0001\u0001\u0003s>|F\u0014&_\u001b\u0018D\u0017u2gR~7{W^?\u000e\f\u0019fC1@bW/Hlx^[E\u0016Pq\u0003\u001evz\u001cJMG?\u000b\u001c9zdwvzV4K\f[[\nxH\u0011B~\u00106U}\u0015.e\u0012N|J\u0004asg|2.\u0017646~_#Mi\u0005\bxAa;+y8\u001eL6g|Cj#\u0002=p_hll9w#f\u0000k'*\u0006G\u001c\\\u0007\u001fH\u0018yN>5TXw&cl1\u0004\\vw,\u0019hNB\u0003\r'\u0012\n9c.\u0007V)\u0011\u000b%(\f7XJegahT#:Cj\u0002jc/5r#h\u001d\u000f-z\u0014F\u0011vTP=/i<g\u0003apj{{\u0017\u0002#\u0010o;7i;6pd9cH%\u001c#\u00139wo[dD*\fI{7fz0&b/eL\u0018<8\u0006W\u0003\u0014Wl\u001c9vZ?5g\u000fW4b\bDs\\RH\u000fX]\u001d,(DtW'/Y>w/]GgMRT\u0007\u0013~]K\u0000BW\fk/T\u001a\t\t}[Ea\u001eZT\u0017UA^\u0014=s!ZM0\u0001q\u0003 1\u000eA\u0016tuuE\u00055@\u0012)?u?FNWMH\u001b3l`\u0018\\\u001f)\u0001U\u001d\u0019\u001ee'[\u0002hH\u000fL>M*#J\u001ek=\u0010rAzKm\u0001!\u000366oB\u0011\u0014/j[g\u0006]:{[\u0001O5\u001fNg-Zdx\u0019mu]x1b` zk>B@\u0014jl\u0017\u0002n\u001ek\u0019,\u0013_hFj\u0013\tzv)T8:79~-\u0000cl-nzx`\u0018T\u000294C\u001ag\u0011}+k~+\u0010'H;HdGT\n\b\nw~{OM\u0003N@hpr^\u0019\raa,=2g{b{c\u0019XQ_A*xsIjLgy\u001fl6%:fz+\u0007R\u0003\u0013t[vNt\u0012\fi\u00152q9\u0011\"$Z>D:\u0007*xqAj\tA02iS?\u001b\u000e7(\bv\u000f\u000fw\u0016FvL\u001dT\u0002>TO3+\"J\u000f\u0006Me$Sy6\u000e\u000ed@\u0004TR\nx@]\u001eZ\u001e\\\u0010fn5^&\u0015\u0015\u0015V>^&{O\u001djYPlf6$;}i1~\u0011c.-Kk\u001b\u001bL(g;lx$t\u0019;\u0011\u000e\u000e\u000e'N\u001evHmo\u00160!3rmmi\u0014\u0001\u0004\u0010D50C\u000b\u000b3\u001a4:N)\u0012\u0018IEC\u0001Ke\u0005-9)q2F\tp\fGi\u0007%tX'*@z2fB\u0005X\nm)B@J\u0010Z]xaI\u0019L&[B02]O542\u0014p9LaI\u0017O?{Nng~\u0014DT\u0013K\u0006l_\u0005Da[9#ydN5\u0005F\u001f\u000ex\u0010@]@\b\u001b;\u00111.JMO_zR`RLl\u000f\u0019Rzh&dh!H \u0000wN <x8l\u000b\u0015\u0002GrMioF\u0017u\u0005\u0001\u0000ntd\u001a\u001dha\u0014'`t'\u0013\u000b\u0013zmaKB>/\u0017\"\u0019s%BWt5\nU(\u0013Kk\u001fZ\u0003u?\u0007iWv+\u0006xbR\u000fZF\u0002-0|\u001470Y\u0017_dpz\u0012C3g\u0017V]>OL\u0019#\u001b\u001c~gn_)L)2d611EB!djf\u0006)Eq\u0013560lnBTEt\tiRNwCo\u0000J\u0000\u0002\u001dc\"|`\tVhE\u0004}\u0006B\u0001?\u0007hVv\u000e=\u000eb\u0011\nz:nkU\u001b\u001a\u001arCG6\u001ehxb)qZ\nF!<yr\u0011BAdHwa\u001e\u001b}\u0019\f\t\u0005^uOsU3'Ar\u001b!\u00038\u001eC\u0011p>hu\u001d>~RB\u0017?:?NaMOhq;tRq\u0000|\bs6\u000f_?[q}>\u0013$vU\u001d1s\u001dZ\u001a{ye\u001aP\u0015V\u001e\rm\u000f(Y{~y_n\u0014\u0004\u001a\u0011:O\u001a-|\u0013v261cox@\u001b_Y.E$\t20\norJ\u000575-}V^[:s_\u0001CkFt:[\u00025\u0005s]}\u0013R\u0015B\u0013Pw|\u00119&rj#G@1I;Nv\u0010sxreultF\u001do/\u0003\u0004(F{%\u001cmfbb\u000f\u0005F\u0012z\u0016w\\\\\\]+a<+V\u00065\u001fL(\u0014\u001a8@<f;\"k#\u0010=?\u0000\u0001\u001eJI%\t.]MRE5\u000eM,\\)p6\u0016\u000bx\u0017_VAR%cC=\u0010\"n\\cqyTtn>GuE\u0017\u000232\\St\t&u:=5:\u0018\u0018t\u0002?}E!7-\u001d3,MW\u0014\u0006b{R|Q\u0004\u0007V\u0006\u0010]\u0013\u0010\u0013QS\nJ\u000f|\u0019_WWW\u000b8sW\u001f'\u001e($\u0012\t\u0001\\';w16)+lt92\u0013Bto_}\u0006}yT\"\u00167P\\>|M7os$hf~\u000fl1sm\u000e\u000b\u001eZ_ZY\b\u0010R`\u0013`6\u0016y\t}W]GYV\u0014YISw5er[y}Q\u0005A%5:7B*r/\u0000f8fX18\u001fh@Eo\u001f.\u0016AE\bk\u0012=\u001b\u0017\u001c\u001b\u0019\u0018W(2_>\u0018j}\u000b;dEV^;mZ[eO[c\u0004pCrS~,\bW8\u0007\f+\"3o`N`P\tPu\"NvN6>@\u0001h8S\u0006CvMsW\u0014U}\u0019\u0018\u001coo\u0019f^\u00037\u000bK\u0018\u0012\u0001t?oB*\u0012\u0002\u001aB4v*hP{ii1\u0010\u0015<\u0015NC}6eOG7+M\u0010\b){\n\t\r+?W[]H'\u0007{+OgL\u001c\u0016\u0007\u001aN\u0019 lEq0pB$\u0015ww\u000330g\f*\u0001J\u001e\f6\u0006\nVMN?*\u001aX;t\u0013\u0010~\u0013.T\u0017<A\u001azN33hs\u0017.x\u0005\u0006\u0001C(BO>\u0001\u0007-pZ77\u000e7L$x?\u0004(;;Q\u001eX-\u000bz;\u0002~\u0013\u0001y\u0007^~vU\u001aFLo\u001foqafRzF\u0017v,4C?Gz3&7\u000ff\r*\u0001N:F\u0016L\u0004R.&?%J?L;qJ$1cY}e\u0018\u0018\u001a!zF7|9$!\n\f\u0001\u001a\u000f\u0011A\u000f\u0012144n\u0016+G\\c'H.H5\u001f\u0004I\u0005\u0013!j_p\u0011\u0011{5mlX`\u0012DC\u001bkD\bnVQ[\u0010bN\"X\u0016w|3B\u0015,;'\u0005\b\b\u001d\u0001[ZD\u00060R|\u0000@o;\u001fw\u0002vi\u0012LrDoT(U~\u0006fo2\u0007\u00034\u001ct1;*)STJdezd~\u001e=n%D\u000f\u0003\u00030\u0007\u001b\u0006\u0006{$\n\u0011\u000ewq,w\u0017>)>q\u0001He\u0018\u000eNNN%2C\u0003\u0018K[-\u0016\u001f5\u0001 =\u0001C\u0010f\u0004\fP\u0006%JR+{[pRISjt'j\u000f=\u001ci#>>>:iw[^jB9p\u0007N3=wpc'&RAUffJ\u0015\u001eFKYSk+foPih>\u000f<PwLt\t%6sg>\"\u0016\u0015\u0013k03LLLzo,{@`\u0002\f\u001ay\u000f\t\u001fX;z;8,--%\u001f\u001b^RQ\u0006@{\u0018\u0003\u0013b\u0000|\b\u0018\u0013&N6k=7w\u0003\u0007A}[_\u001d:2li)\u0019c[+PC8sG\u0007{\u0011u~r4\u0004VsG\u0010ag++}nt~Yut9c\n\u000eearT%\u0019H\u0005~i'\u001bq\u000f_\u000fsssHP@z\u00017_\t\t\u00005`\u001fesJ\u001bwSYm\u0014~7Si/[]TYpO1%/yJ\u0010U|\b\u00102:\"P#\u0011=n\u0015\u0011`)\u000b)ngo3[\u0019y\u0019}+eP(iN#\u001fM7}ki\u001eK\u000f[ 3)kFK\u0017\u0003\u0014\u0006\rD5H8<\u0016\b=x,$\u0014\nz\u0013E5>\u001622d\n&\u0006\u000e#(~+H\u000egPju=x\u001c\rZ\t\u0002\u0016\u0014\u001ae\u0012w(-\u000b>Trke]%\u0003H\u0002h\u0003\u0005M=-l>l\bD\f\n\u0019iNYU\u0017al9*\u0013M[i`tc3nyF\u000b\u0017\u001bb@\\N\u0010nF\u0011\u0018L\n\u001d`z8!\u0001\u001e:zMo\u0006\u0010E'p\"Q \f\u000ewk\u0006\u0013f'IQX\\o9\u0002\u0006\\JE\u001eDa\u0001thnHiaN!&\"/CG\nYi\u000e\\&wF[+x\u000e5\u0004QQ[\u00144|]47in=P!0l9h\u001ci}:?EG&&;7ecPz?>\\[B19\u0017hH\u001d\u0004\nv_p\u0019?\u0011\r\u00078<{\u0007?O7^;t4&&f\u001fp\u0007O\u0014ONvm\u0018,\u0016M1CoP\f\u0011p\u0004\u0003JeX[kHO\u0004<\u0001\u0004\u0007\u0006iY\u0002T\u0012WBv[RcI\u0006mF\u0002dA(\u001b\u0013\u000bt $\\b\u0013\u0015h\u001f\u0018\u0014\u0002g\u0001{=<E]S@>gB\f~5mv\u001e\"QF*J`F=\u0006\u0012}o\u001755\n\u001e=\u0016I\u000fn\u001d\u0004z\u0014D\n\u0000Sz\u0014P\u000f\u0004aTp33{Ii\u0019wq#\u0014-Z<f\u001d)w\u0015\nE76RJ\n\r\"X;vp\u0013I\u0018<\u001a\u0010\u0001\t?H$@2\u001bM\u001c$j\u001aZUlL&iu<<< \u0011LR^\u0003\u0010\u0016H\u000bR^A!f\u001fj\u0012a&_M\"\u001c\n\u0017Hj\u001ftL@V\u0006zO]@\r5\b|}2'\u001a\u000e\u001d|\u00003)=_\u001dicc5 \"0y| !\u001e'^[X3 >\u001d\u000fBU\u0007+\u0001|#kk\u000e}\u0002K_v-u=\u0011v.\u001f;8T{b4D\u001c5_rurbY6X<\u0016m\u0000IF!ID\u0003<01\bQ\u0007b\u0018\u001a@`\u000eA\u000e\u0001M\"ilZj\u001eaD\u000e\u0011l\u0014\t0\b\"\bDU~'\u001cA!C\rKm<}PTm=X?xE6J\u0015\f\u000e\u0007x,?D?7\u0012xiZR\u0001[:rh~\u0015~wNn\u0014\u000bk>\fO!\u0011$) >\u001axH\u0002}?$0RiG\u0004Z\u00077\u0006eV=A\u0013a\u001f'O\u0011\u001e\u001e~;`>ga\n\u0001\u0015/\u0013\u001cAV\nNw.SuB5`qZ\bau\u00178\u0006655v=\u000b\u0004\"\u0011h\u0013\u0004%\tB`nxX,\u0007h\u00146=\u0001<F#APT\u0001\u001a`A!/mcK\u001bO%j6n.\u001fH4@\u00013*Z\u0001R*\u0019U 7Rb0\u0016^m-fG}\u0019\u000f\u001ar\\}\u001f}Q2 <=3k\u0005KW|]%\u0003+\u0017ru\u0000X{$X\u00194\u0002TzX-\t\u0005w?ovvvIK\u0004\u0002K\u0017?as'EEl/fBj~#\u0014!OR\u000ek~\u0017\u0004w\f\u001du&hCu*\u0003\u000f=R.x^H1VjX\u001c`*\"!,\u001e\u0010\b\u001a,$\u0003D\fH\"\u0002$\u0001(4*\u0005\"Xk\u0013\u00004dxagw{=R)\u0011t$H\u0006IT\u0000\nm4ZBT#|\tX\biGi;\u001a\u0018\u0003Ks%O/(hkks\u0002\u0002)1c:\u0003[l\b<ER\u001f%]\u001fD\u0003[L\u0001$j\u0018`P+\u000b\u0010PNU\u0018\u001bW\u001a\u000eA\u001cf\u0007dmm\u001d3fiZ3;\u001f5[,.+%8)\u0005-wB\u0014En\n;bJ-?9f\u001c;K?\u0000mas\u0005>3'1zB}~U,\u0006|p1:s'B_\u0000;\u0017yG_=4\u001d\u00067\\OS\fG4\u001f\u0012_\tHo\u000fJ3KKROGOF\u0010'\u0004wl,>H(\u0004\u0013?Z3c+.~\u0001i1cG\u000011n\u0002\u000esw%\u0003G*\u001cD\u0004>-m\u0011=RD\noGrd-X[\u0015\t8dn@T>:\u0010gzVW>1\u0013\u0012zrg\u0015b~cy=vU\u001dGi[\u0018}\u0010\u000b\u0012\u0017fe{\u001c\u0014*D\bh\tP\t<Lb/+=\u0003C@j\u0007KP\u0004\u0000~\rp\\K\u0007g\n2,c\u0011\u00126s+p\u0004\r}kQa\u0002h\\qO)V.\u001d\u0016}{ZYY)>RudZWV@>[7<:#9{\u000e&C\u0012\u001b\u0019KWlibu1,\u0016\n#G4\u001cy4w\u000712u/K\u001bNX\u0002wR.+pQV\u000b\u0017).q\u000bZL\"yR\u001egD)/ES\u00171\b\u0019FhnRY!o\u001c:523\u0002\u000e\u001d#Y\u001e{Y\u0014V\u000fgpX\u0002;\u0001\t6\rD-Z,\u0007\u00077\u000fG\u0011m96p-\f\u0012\u0016hhh\u0003}1&|1<iHKkk\u001d+\u0016>3pz3\u001b+nu%}4\u00133(26'*8{J\u001d\u0003/&(Dsz7[%(l#,`%e$me4[V\u001a%}O\u0007%@`Tdj ,\u00174x0\n.:\u000ej:cBEb\u0003L\u000b;\u001e$\u0005\t^U\u0004.=xx\u001a7\u00163MvV\u0005c142F\u001d\u0002<{NN\u0013M\r@NjO<;JL\u001f@\u0013wo\\0e\u0012S_\r5\u0017Jc9[H\u0010(\u000f<|\u0019 \t^5\u001bk:k(s#g[\u001aN3*o\u0001&\u001ehx\u0000?\u0000[Gujc\u001cfMl@m\u0005T\u0015UrR&V\n]\u0014G\u0005jo\u0011Hd\u000egQ`ll\u0013O:W\u001c?\u000b\u0004N\u0001f(z\u0017V\u000e\rK\u0018.\u001e\u0012K2\u0013\u0013\u001e^/\\\u0016q!\u0011\u0013D{\u0014GaZ9]>!V*Nw9L^\u0015\u0014\u0016F564\\\u0006ZN8sl}M\u0011IWKG6\u001eDfiBS\"\u0012.zj\u000fg>P}=0d(kZy\u0007cY{DewJUR\u00048tS\u00188iX<B\u0000\u001fK\u0002\u0011M\u001enIH:T\u000eB\n6\u0011F;\u0016H}P:S;IfM\\7\u0010\u0001\u0010\"9\u0017JvG\u0017\u0014]Pwr:[%T~\n\rT|t\u0017/\u0015f7\u001c3*\u0002tqq+g?q<\r\u001f~\u0018tbbVcK=[\u001e\u000fq\u000b\u0019\u0014T\\{KnPy'^\u000eT/rR(=r\u00017`Z+{8`\u0002 \bCtZN\u001a\u0015\u0007\u0002#[2k\u0006\u0003#b1\u000fM\\3\u000e8GKd\u001f:y\u0005\u0001U::?-[n8phfD!pIF|eB\u001dK{GG}_\u001cacC<`\u000e\u0013VN{b7cM\u0011\u0004.X<PcYt^~\n\u001e;~~Rt|}q1\u0013wC\u001e@H4Yw[&\bz\u001d\f#si\fj\u001b[;\u001c\b\u000b8 \u0007\u00193\u0015S\b8\u000b+>d%a\u001e88\u0012]\u000f\bN0\u001c\u001ax~/?x>O{dGUQus3\u001f\u0014.\"/#\u001fiY#\u000e;\u0000-Q|\u001d\u001c\u0016N\"\u0011!\u001c\u0016Rq:mrRK42d8{\fS/\r%,ghssb'\u000fv\u001b=7]CG3I\u00166v\u000e\u0004!sCn\u0003P\u0019s\u0003\u001c\u0013^T~N!3*\u0002\n#Z\u001e\f/?G\u0019\u0014\nE\u00120mp\u0015ly>`i:\u0001{i7\u001e+\b\u0019^\u001fId#)7\u001aI\u0019\u0010IDX?\u0003b^-\u001ex}NW9(l+ M#V_Zs\u001c~S^\u0017o}5\u0019D\u000bc\f\u001b[ 79@ua_p*\u0011M,F\u000e*\n\u0010 \u0004k\u001a\u0010\u001db\u001215aJ]Y\u0013\u000bUV)04G+-1mQ\u0007o)/\"*O\u0011:ck[C##~NTAjBU$\u0012g\u0000L*mS?%?kgE\u0014`\u001eGS7z`C\u001c\u001c\u001f&|\u0010\u0007z\u000b\u000fs\u0000/Ad\u000bT\u000e(HOsg5\rAj\u000f\f\rw|\u001e`sV}\\C]D3gV~e[w\u000bYGP+\u0016f&_rt\u0018\fdb\u0001O-\u0011^G4q\u001f\bdYn6}1D<^(eE?\u0006o\u0019\u00198'16\u0003uJ\"kqom\u001e\u0018q\u000e\u001a,p9#\u0012\"_i,:F!Y\u001cTXBE\bx\u000e-D-l`MP\u0006T\n$r!D\rkTE:\u00049&gl]+mBiq\tf\\8whUq \u0019c.cNv\u001d0#x,#n8?%kp<3MezUs\u0019\u0013_92fg:G9FJ,\u0018\u0001z\u000b7m80\tmAF3\u0003Uu>A\u0010\u0003\b\u00104+6\u001f8\u00040\u0006(dr4D1L641o:F.\u001dYR3'\u0012\"\f}zY\u0001A8CC\u0016\u0019cy\u0003:)/4 l\u001fP\u00169~AJL\f\b\t0gmF\fL~u\u0013]q7\u0010+\u0004:}\"t\r\bR\n8W*E)Ni\u001c\u0005\u0004rm^'FvV\u001eipj255A\u0003|\u0019z\u00019\"ZM\u0006KXale;\u0018p:cZX?\u0010*\u0012s_j2,F/$\u001d\u001eVv'K\u0013&s\u000bPfV]\u000e*?uQ\r~ptq5t\u0017My=*\\\b\b\u0012uw/H\u0011\u0007OxJ!R\u000e(?)j$vU\u001eQb\b;HDBo5\u00126$,K\u0015J\fsiw~\fQ&D\u0010YBIO`c\u001f^MF\u000eg\u0014\nWc{\u0002Spq\"^N^Jw,[\u0000TR\"\u001a_\u001eJ7q8Kl\u001cLLR!}Wy\u0013x^|\u0013\u0018f!#CC%v9)q}kl\u0006rofD\u0004.J}#<\u000fq;k>t\u000b\u001a\u0016\u0015\u0017\u0012\u0013\"H\u000fcw*\u0017\u0002-Pr\u0013^k\u001aw_NNNrIg\u0001\u001d^\u0017vDL60\\\u0004!Z\rWKs(w\u0013\u000135B9q^O0\tp\u0019\u00175#N\u001a<f7u\u000f\u0019_v\u0011\u0019AH\tX\u0019y0<ZtRtyzy\u0007\u0005i/\u0001JJ\bV\u001330\u001cM62\u000e$\u001b\u0000\r\u0012r\fInEQh\u0001@r\nG\r\bI>)qw_F\u001c\u001cqzLrm-;f1#\u0010Id\u000fUMl%\r\n\bOF9xP&B0<L7@L0(752:\b\r$\u0012I4\u0012\u0018Kg\n\u001c\u001fba\u0011\u00100sQ\f-d\u000b\rx\u0007\u001bCB.\b=}\u0005-c\u001e;oiT\n~\u0007Z\u0004lmZ\u0010Fq(\u0004W`!e\u0001J\u001dh:0\u000b~a ~WSJf\u00014[9Q*\u0004Z=<|dvs\u0000\u001en\b\u0011hW|}\n!K? %YgBX/\u00113\u001d\u001d~fFQvdmg\u001ax_\u0012\tD\u0003\bB\u0018)\u0019\u0010_r\u0010\u0014Q\u000fD\u0019i\u0011EinepGN\u0005b9\u001a~\u0016rb%c>\b\u001duj!ATa\u0003<nC\u000fo/.\u0013\t\u0013\nSd.}\u0004O:s$D\u000eh\u0011]\u0005\u0004\u001d\u000fFMeVEmc` \u0012xbV\t`Z#\u001d\u00049\u0018=xa)\u0004\u0003\u0010\u0002b\u0001CB%\u0016\u0007hF,\u0004}0+u7#]\u001d'F>J\u0006\u001d'\u0010\b\n\f7[\u0002N\r@RG=\tX3\u001e\u0014)}E!|\u0017\r7g'GrIz-'U0o\u001e8l\u0015\"\u0015]\u001e;\u000e8o-RsK5\u001el>Q@P*L5N10ZuR$<45Kf<]\t\u0005l\\[\u0012DT=pv\u001f\b\u0015gg0EVV=diw(a3}A\rp\u0017Y\u0013FF\u000eE\u001b\f)\u0001N9*\t\u000689`\u001d\u000fgWs]lg7{`DR7\nRR\u001a\u0013qi\u001bAU&6v\u0004\u0004\u0010\b,Lc):NHd1R.\u0012VrxutZ#\u001aM2\u0017/zU\u0017T%\u0019\\\\];:9\u0012bS_\u001eCJ\u0000=6\u001f\u0015\u0011'cwUwQ)dk\u0014{q_7wF \u0010r\u0001}1\u0013-L67\u00044ER(+iP.\\B-`X\u00030\u0004\u0000GP-mD.WHPd1\u0006im\nF0\u001dnS\u0014r\u0005D\u001bb\u0014\"\u0011\u00129jAzBE\u001dZRk#8|8B\r#\fmT>H?\u001bw\u000f\u0001\u001efV\u0001eN\r6\u0000g.c|\r{\u0002Q\u001ep\fm<ioEi1\n\u00077\u000f?T\u0014rc\n\u0013n3K\u001bO:hD\u001dJ22\u0019C526P(>DQjBVtJ\u0012Cncg\u0011tW\u001e!'\u001e.\u0004^.\u001a\nC:mZ\"\u001a\u0014JG\f6U8y\u001c!\u0013F\u001e|\u0011$\u001dhfF\u0018SR\u0005\u0003BzC}\u0003.Q% L`\u0002\\V0\u0018J1Y1kf\u0015\u0004(mhP\u0011;:H8\u001eR.G\u0010.!\"\u000f#:&\u00061A8`tDRy4yF5.l@+o~\u0007Rc\r/Y3\tNK> \u000ft\u0017=k{e]\\+++Y5+f\u000bW\n\u000f\u0016\n\u0002\u0014\u001d=#sp \u00101X=\\;9cP ~q)EVT*ZhG8\u0018\u0016\u0019\u0007wg$\u001c\u001e;\u0018:}`N71&E+O^*\u0004Dha\u0010!\u0010SW|o\u0016\u00176\u001f<2;L\"dv\u001c\u0013;>U0\u00048y\u0015I\u000bp9_K%f\u0004h\u0003\\lF`s\u0002\u0011o@X3\f`%\u0010l\u0004\t@\u0011I$\u0018SJDTF4Vs:?=e U]?bi-ouOQM}\u0012Gpto\"s?*\u0000W)L\u001bhWPl?\r\"7rN\u0018r\u0002l)\u001f\u0012\u0007#ZR,Oo@XX1C N\u0003nV\u0013P\u0011(T\u001f\u0001EVD/\nI\u0013/\u0015zOM\u0017\u000fG\u0007\u0007~J'*\u0001\u000bGx!\nB2?#`\u0004'/_/Pvuv|T!%\u0018\u0013Gt\u0011Q(7-cF\u001a\u0018\u0013\u0006,\f\u0014*nF\" L\"R\t\u0018\u00149\u001aNJ6\u000f\u000f\u000f5Q\u001agp4\u000b5V\f\u001b\u0003yJ\u0001o'\u001eO\u001d]m\\|-\f\u0001\tZ\u0010Rg\u0015\f\u0000W*N.\u0012v;4SA+dZ\u001d\t\u0019YM615t:RQJ\n~|XvoM`%\u000b;.\u0013/i8\u0019 Q\u001a\u001c=X,\"a\u001eFPh\u000b5CT_\u0006$w#T}0/z,\u0000\u001cdJ$\u00041AF>blu5\u0005\\B\\p\u000b\u001e\u0019\u0010\u0012Jw<\bP*wy|:\u0005c\r\u0006'\u0017\tZT\u0012\u0005_pO`fg/l@!+D|\u001en3\u0010`CEx\u0017o0\f\fBi1z\nPuP^N\u0002uNAP\u0004Qz>([wBFrhy|'\u00108y0u:\u0014Y[\u001aQz\u0012\u0018,\u0002r^T\u000b9i5TvoY\u001bDv5^VR.\u0017i\u0004=/L77e1t9Q\u0007US\u0004tBa?\u0017Ww#\t=?1A-f\u000et~y(X9a`2%#&w\u000bo\u0004\u0004A$\u0017K\u0002tM\u0000Hh\u001b_\u0003\u0019\u0017?j:zr\u001f_\\{iZ7\ru@\u00044g9<7\u001b\u000b\u000bod\u0007{RAC.(i`\u0016\u0018\u001fI8t\u0000]\u0012;\u0018&)#_\u0001$\u001dhLkP5J)w<\u001d(7q\u0000$)\u001b0i\u00042g\fgRM:/\u000b:p\u0000$iegs\u001a:\u001f\u001b:\u000f4Z(\u0017k\u000e\u001a.`\u0002\u0006\u0003h6NJYZY@`4\u00010\u0013ST\u0017~\u0014ag2Z\u000548yb\b\u001b.M\u001c:`4\u00010&\u0012f\u0013A\u001e4\u0018`4\u000106b\u0013\u0014SRV)\u0001f`4\u00010`ci4\u001f`4\u00010@6lzVK2)m(\u0004\u0000\u0005S\u0017H\u00193xteJh\t0@|V6>\u001a>\u0006\u0018ik&v11qo?\np\u001b1\u0000\u0000\u001coY\u0000\u0000\u0000\u0000IENDB`",
  "jszip.min_3.1.3.js": "/*!\n\nJSZip v3.1.3 - A Javascript class for generating and reading zip files\n<http://stuartk.com/jszip>\n\n(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>\nDual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.\n\nJSZip uses the library pako released under the MIT license :\nhttps://github.com/nodeca/pako/blob/master/LICENSE\n*/\n!function(a){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=a();else if(\"function\"==typeof define&&define.amd)define([],a);else{var b;b=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i=\"function\"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error(\"Cannot find module '\"+g+\"'\");throw j.code=\"MODULE_NOT_FOUND\",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f=\"function\"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){\"use strict\";var d=a(\"./utils\"),e=a(\"./support\"),f=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";c.encode=function(a){for(var b,c,e,g,h,i,j,k=[],l=0,m=a.length,n=m,o=\"string\"!==d.getTypeOf(a);l<a.length;)n=m-l,o?(b=a[l++],c=l<m?a[l++]:0,e=l<m?a[l++]:0):(b=a.charCodeAt(l++),c=l<m?a.charCodeAt(l++):0,e=l<m?a.charCodeAt(l++):0),g=b>>2,h=(3&b)<<4|c>>4,i=n>1?(15&c)<<2|e>>6:64,j=n>2?63&e:64,k.push(f.charAt(g)+f.charAt(h)+f.charAt(i)+f.charAt(j));return k.join(\"\")},c.decode=function(a){var b,c,d,g,h,i,j,k=0,l=0,m=\"data:\";if(a.substr(0,m.length)===m)throw new Error(\"Invalid base64 input, it looks like a data url.\");a=a.replace(/[^A-Za-z0-9\\+\\/\\=]/g,\"\");var n=3*a.length/4;if(a.charAt(a.length-1)===f.charAt(64)&&n--,a.charAt(a.length-2)===f.charAt(64)&&n--,n%1!==0)throw new Error(\"Invalid base64 input, bad content length.\");var o;for(o=e.uint8array?new Uint8Array(0|n):new Array(0|n);k<a.length;)g=f.indexOf(a.charAt(k++)),h=f.indexOf(a.charAt(k++)),i=f.indexOf(a.charAt(k++)),j=f.indexOf(a.charAt(k++)),b=g<<2|h>>4,c=(15&h)<<4|i>>2,d=(3&i)<<6|j,o[l++]=b,64!==i&&(o[l++]=c),64!==j&&(o[l++]=d);return o}},{\"./support\":30,\"./utils\":32}],2:[function(a,b,c){\"use strict\";function d(a,b,c,d,e){this.compressedSize=a,this.uncompressedSize=b,this.crc32=c,this.compression=d,this.compressedContent=e}var e=a(\"./external\"),f=a(\"./stream/DataWorker\"),g=a(\"./stream/DataLengthProbe\"),h=a(\"./stream/Crc32Probe\"),g=a(\"./stream/DataLengthProbe\");d.prototype={getContentWorker:function(){var a=new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g(\"data_length\")),b=this;return a.on(\"end\",function(){if(this.streamInfo.data_length!==b.uncompressedSize)throw new Error(\"Bug : uncompressed data size mismatch\")}),a},getCompressedWorker:function(){return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\",this.compressedSize).withStreamInfo(\"uncompressedSize\",this.uncompressedSize).withStreamInfo(\"crc32\",this.crc32).withStreamInfo(\"compression\",this.compression)}},d.createWorkerFrom=function(a,b,c){return a.pipe(new h).pipe(new g(\"uncompressedSize\")).pipe(b.compressWorker(c)).pipe(new g(\"compressedSize\")).withStreamInfo(\"compression\",b)},b.exports=d},{\"./external\":6,\"./stream/Crc32Probe\":25,\"./stream/DataLengthProbe\":26,\"./stream/DataWorker\":27}],3:[function(a,b,c){\"use strict\";var d=a(\"./stream/GenericWorker\");c.STORE={magic:\"\\0\\0\",compressWorker:function(a){return new d(\"STORE compression\")},uncompressWorker:function(){return new d(\"STORE decompression\")}},c.DEFLATE=a(\"./flate\")},{\"./flate\":7,\"./stream/GenericWorker\":28}],4:[function(a,b,c){\"use strict\";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b[g])];return a^-1}function f(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b.charCodeAt(g))];return a^-1}var g=a(\"./utils\"),h=d();b.exports=function(a,b){if(\"undefined\"==typeof a||!a.length)return 0;var c=\"string\"!==g.getTypeOf(a);return c?e(0|b,a,a.length,0):f(0|b,a,a.length,0)}},{\"./utils\":32}],5:[function(a,b,c){\"use strict\";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!0,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],6:[function(a,b,c){\"use strict\";var d=null;d=\"undefined\"!=typeof Promise?Promise:a(\"lie\"),b.exports={Promise:d}},{lie:58}],7:[function(a,b,c){\"use strict\";function d(a,b){h.call(this,\"FlateWorker/\"+a),this._pako=new f[a]({raw:!0,level:b.level||-1}),this.meta={};var c=this;this._pako.onData=function(a){c.push({data:a,meta:c.meta})}}var e=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array,f=a(\"pako\"),g=a(\"./utils\"),h=a(\"./stream/GenericWorker\"),i=e?\"uint8array\":\"array\";c.magic=\"\\b\\0\",g.inherits(d,h),d.prototype.processChunk=function(a){this.meta=a.meta,this._pako.push(g.transformTo(i,a.data),!1)},d.prototype.flush=function(){h.prototype.flush.call(this),this._pako.push([],!0)},d.prototype.cleanUp=function(){h.prototype.cleanUp.call(this),this._pako=null},c.compressWorker=function(a){return new d(\"Deflate\",a)},c.uncompressWorker=function(){return new d(\"Inflate\",{})}},{\"./stream/GenericWorker\":28,\"./utils\":32,pako:59}],8:[function(a,b,c){\"use strict\";function d(a,b,c,d){f.call(this,\"ZipFileWorker\"),this.bytesWritten=0,this.zipComment=b,this.zipPlatform=c,this.encodeFileName=d,this.streamFiles=a,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}var e=a(\"../utils\"),f=a(\"../stream/GenericWorker\"),g=a(\"../utf8\"),h=a(\"../crc32\"),i=a(\"../signature\"),j=function(a,b){var c,d=\"\";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},k=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},l=function(a,b){return 63&(a||0)},m=function(a,b,c,d,f,m){var n,o,p=a.file,q=a.compression,r=m!==g.utf8encode,s=e.transformTo(\"string\",m(p.name)),t=e.transformTo(\"string\",g.utf8encode(p.name)),u=p.comment,v=e.transformTo(\"string\",m(u)),w=e.transformTo(\"string\",g.utf8encode(u)),x=t.length!==p.name.length,y=w.length!==u.length,z=\"\",A=\"\",B=\"\",C=p.dir,D=p.date,E={crc32:0,compressedSize:0,uncompressedSize:0};b&&!c||(E.crc32=a.crc32,E.compressedSize=a.compressedSize,E.uncompressedSize=a.uncompressedSize);var F=0;b&&(F|=8),r||!x&&!y||(F|=2048);var G=0,H=0;C&&(G|=16),\"UNIX\"===f?(H=798,G|=k(p.unixPermissions,C)):(H=20,G|=l(p.dosPermissions,C)),n=D.getUTCHours(),n<<=6,n|=D.getUTCMinutes(),n<<=5,n|=D.getUTCSeconds()/2,o=D.getUTCFullYear()-1980,o<<=4,o|=D.getUTCMonth()+1,o<<=5,o|=D.getUTCDate(),x&&(A=j(1,1)+j(h(s),4)+t,z+=\"up\"+j(A.length,2)+A),y&&(B=j(1,1)+j(h(v),4)+w,z+=\"uc\"+j(B.length,2)+B);var I=\"\";I+=\"\\n\\0\",I+=j(F,2),I+=q.magic,I+=j(n,2),I+=j(o,2),I+=j(E.crc32,4),I+=j(E.compressedSize,4),I+=j(E.uncompressedSize,4),I+=j(s.length,2),I+=j(z.length,2);var J=i.LOCAL_FILE_HEADER+I+s+z,K=i.CENTRAL_FILE_HEADER+j(H,2)+I+j(v.length,2)+\"\\0\\0\\0\\0\"+j(G,4)+j(d,4)+s+z+v;return{fileRecord:J,dirRecord:K}},n=function(a,b,c,d,f){var g=\"\",h=e.transformTo(\"string\",f(d));return g=i.CENTRAL_DIRECTORY_END+\"\\0\\0\\0\\0\"+j(a,2)+j(a,2)+j(b,4)+j(c,4)+j(h.length,2)+h},o=function(a){var b=\"\";return b=i.DATA_DESCRIPTOR+j(a.crc32,4)+j(a.compressedSize,4)+j(a.uncompressedSize,4)};e.inherits(d,f),d.prototype.push=function(a){var b=a.meta.percent||0,c=this.entriesCount,d=this._sources.length;this.accumulate?this.contentBuffer.push(a):(this.bytesWritten+=a.data.length,f.prototype.push.call(this,{data:a.data,meta:{currentFile:this.currentFile,percent:c?(b+100*(c-d-1))/c:100}}))},d.prototype.openedSource=function(a){this.currentSourceOffset=this.bytesWritten,this.currentFile=a.file.name;var b=this.streamFiles&&!a.file.dir;if(b){var c=m(a,b,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:c.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(a){this.accumulate=!1;var b=this.streamFiles&&!a.file.dir,c=m(a,b,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(c.dirRecord),b)this.push({data:o(a),meta:{percent:100}});else for(this.push({data:c.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var a=this.bytesWritten,b=0;b<this.dirRecords.length;b++)this.push({data:this.dirRecords[b],meta:{percent:100}});var c=this.bytesWritten-a,d=n(this.dirRecords.length,c,a,this.zipComment,this.encodeFileName);this.push({data:d,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(a){this._sources.push(a);var b=this;return a.on(\"data\",function(a){b.processChunk(a)}),a.on(\"end\",function(){b.closedSource(b.previous.streamInfo),b._sources.length?b.prepareNextSource():b.end()}),a.on(\"error\",function(a){b.error(a)}),this},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(a){var b=this._sources;if(!f.prototype.error.call(this,a))return!1;for(var c=0;c<b.length;c++)try{b[c].error(a)}catch(a){}return!0},d.prototype.lock=function(){f.prototype.lock.call(this);for(var a=this._sources,b=0;b<a.length;b++)a[b].lock()},b.exports=d},{\"../crc32\":4,\"../signature\":23,\"../stream/GenericWorker\":28,\"../utf8\":31,\"../utils\":32}],9:[function(a,b,c){\"use strict\";var d=a(\"../compressions\"),e=a(\"./ZipFileWorker\"),f=function(a,b){var c=a||b,e=d[c];if(!e)throw new Error(c+\" is not a valid compression method !\");return e};c.generateWorker=function(a,b,c){var d=new e(b.streamFiles,c,b.platform,b.encodeFileName),g=0;try{a.forEach(function(a,c){g++;var e=f(c.options.compression,b.compression),h=c.options.compressionOptions||b.compressionOptions||{},i=c.dir,j=c.date;c._compressWorker(e,h).withStreamInfo(\"file\",{name:a,dir:i,date:j,comment:c.comment||\"\",unixPermissions:c.unixPermissions,dosPermissions:c.dosPermissions}).pipe(d)}),d.entriesCount=g}catch(h){d.error(h)}return d}},{\"../compressions\":3,\"./ZipFileWorker\":8}],10:[function(a,b,c){\"use strict\";function d(){if(!(this instanceof d))return new d;if(arguments.length)throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");this.files={},this.comment=null,this.root=\"\",this.clone=function(){var a=new d;for(var b in this)\"function\"!=typeof this[b]&&(a[b]=this[b]);return a}}d.prototype=a(\"./object\"),d.prototype.loadAsync=a(\"./load\"),d.support=a(\"./support\"),d.defaults=a(\"./defaults\"),d.version=\"3.1.3\",d.loadAsync=function(a,b){return(new d).loadAsync(a,b)},d.external=a(\"./external\"),b.exports=d},{\"./defaults\":5,\"./external\":6,\"./load\":11,\"./object\":15,\"./support\":30}],11:[function(a,b,c){\"use strict\";function d(a){return new f.Promise(function(b,c){var d=a.decompressed.getContentWorker().pipe(new i);d.on(\"error\",function(a){c(a)}).on(\"end\",function(){d.streamInfo.crc32!==a.decompressed.crc32?c(new Error(\"Corrupted zip : CRC32 mismatch\")):b()}).resume()})}var e=a(\"./utils\"),f=a(\"./external\"),g=a(\"./utf8\"),e=a(\"./utils\"),h=a(\"./zipEntries\"),i=a(\"./stream/Crc32Probe\"),j=a(\"./nodejsUtils\");b.exports=function(a,b){var c=this;return b=e.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:g.utf8decode}),j.isNode&&j.isStream(a)?f.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")):e.prepareContent(\"the loaded zip file\",a,!0,b.optimizedBinaryString,b.base64).then(function(a){var c=new h(b);return c.load(a),c}).then(function(a){var c=[f.Promise.resolve(a)],e=a.files;if(b.checkCRC32)for(var g=0;g<e.length;g++)c.push(d(e[g]));return f.Promise.all(c)}).then(function(a){for(var d=a.shift(),e=d.files,f=0;f<e.length;f++){var g=e[f];c.file(g.fileNameStr,g.decompressed,{binary:!0,optimizedBinaryString:!0,date:g.date,dir:g.dir,comment:g.fileCommentStr.length?g.fileCommentStr:null,unixPermissions:g.unixPermissions,dosPermissions:g.dosPermissions,createFolders:b.createFolders})}return d.zipComment.length&&(c.comment=d.zipComment),c})}},{\"./external\":6,\"./nodejsUtils\":14,\"./stream/Crc32Probe\":25,\"./utf8\":31,\"./utils\":32,\"./zipEntries\":33}],12:[function(a,b,c){\"use strict\";function d(a,b){f.call(this,\"Nodejs stream input adapter for \"+a),this._upstreamEnded=!1,this._bindStream(b)}var e=a(\"../utils\"),f=a(\"../stream/GenericWorker\");e.inherits(d,f),d.prototype._bindStream=function(a){var b=this;this._stream=a,a.pause(),a.on(\"data\",function(a){b.push({data:a,meta:{percent:0}})}).on(\"error\",function(a){b.isPaused?this.generatedError=a:b.error(a)}).on(\"end\",function(){b.isPaused?b._upstreamEnded=!0:b.end()})},d.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},b.exports=d},{\"../stream/GenericWorker\":28,\"../utils\":32}],13:[function(a,b,c){\"use strict\";function d(a,b,c){e.call(this,b),this._helper=a;var d=this;a.on(\"data\",function(a,b){d.push(a)||d._helper.pause(),c&&c(b)}).on(\"error\",function(a){d.emit(\"error\",a)}).on(\"end\",function(){d.push(null)})}var e=a(\"readable-stream\").Readable,f=a(\"util\");f.inherits(d,e),d.prototype._read=function(){this._helper.resume()},b.exports=d},{\"readable-stream\":16,util:void 0}],14:[function(a,b,c){\"use strict\";b.exports={isNode:\"undefined\"!=typeof Buffer,newBuffer:function(a,b){return new Buffer(a,b)},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&\"function\"==typeof a.on&&\"function\"==typeof a.pause&&\"function\"==typeof a.resume}}},{}],15:[function(a,b,c){\"use strict\";function d(a){return\"[object RegExp]\"===Object.prototype.toString.call(a)}var e=a(\"./utf8\"),f=a(\"./utils\"),g=a(\"./stream/GenericWorker\"),h=a(\"./stream/StreamHelper\"),i=a(\"./defaults\"),j=a(\"./compressedObject\"),k=a(\"./zipObject\"),l=a(\"./generate\"),m=a(\"./nodejsUtils\"),n=a(\"./nodejs/NodejsStreamInputAdapter\"),o=function(a,b,c){var d,e=f.getTypeOf(b),h=f.extend(c||{},i);h.date=h.date||new Date,null!==h.compression&&(h.compression=h.compression.toUpperCase()),\"string\"==typeof h.unixPermissions&&(h.unixPermissions=parseInt(h.unixPermissions,8)),h.unixPermissions&&16384&h.unixPermissions&&(h.dir=!0),h.dosPermissions&&16&h.dosPermissions&&(h.dir=!0),h.dir&&(a=q(a)),h.createFolders&&(d=p(a))&&r.call(this,d,!0);var l=\"string\"===e&&h.binary===!1&&h.base64===!1;c&&\"undefined\"!=typeof c.binary||(h.binary=!l);var o=b instanceof j&&0===b.uncompressedSize;(o||h.dir||!b||0===b.length)&&(h.base64=!1,h.binary=!0,b=\"\",h.compression=\"STORE\",e=\"string\");var s=null;s=b instanceof j||b instanceof g?b:m.isNode&&m.isStream(b)?new n(a,b):f.prepareContent(a,b,h.binary,h.optimizedBinaryString,h.base64);var t=new k(a,s,h);this.files[a]=t},p=function(a){\"/\"===a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf(\"/\");return b>0?a.substring(0,b):\"\"},q=function(a){return\"/\"!==a.slice(-1)&&(a+=\"/\"),a},r=function(a,b){return b=\"undefined\"!=typeof b?b:i.createFolders,a=q(a),this.files[a]||o.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},s={load:function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},forEach:function(a){var b,c,d;for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],c=b.slice(this.root.length,b.length),c&&b.slice(0,this.root.length)===this.root&&a(c,d))},filter:function(a){var b=[];return this.forEach(function(c,d){a(c,d)&&b.push(d)}),b},file:function(a,b,c){if(1===arguments.length){if(d(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}var f=this.files[this.root+a];return f&&!f.dir?f:null}return a=this.root+a,o.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=r.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||(\"/\"!==a.slice(-1)&&(a+=\"/\"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},generateInternalStream:function(a){var b,c={};try{if(c=f.extend(a||{},{streamFiles:!1,compression:\"STORE\",compressionOptions:null,type:\"\",platform:\"DOS\",comment:null,mimeType:\"application/zip\",encodeFileName:e.utf8encode}),c.type=c.type.toLowerCase(),c.compression=c.compression.toUpperCase(),\"binarystring\"===c.type&&(c.type=\"string\"),!c.type)throw new Error(\"No output type specified.\");f.checkSupport(c.type),\"darwin\"!==c.platform&&\"freebsd\"!==c.platform&&\"linux\"!==c.platform&&\"sunos\"!==c.platform||(c.platform=\"UNIX\"),\"win32\"===c.platform&&(c.platform=\"DOS\");var d=c.comment||this.comment||\"\";b=l.generateWorker(this,c,d)}catch(i){b=new g(\"error\"),b.error(i)}return new h(b,c.type||\"string\",c.mimeType)},generateAsync:function(a,b){return this.generateInternalStream(a).accumulate(b)},generateNodeStream:function(a,b){return a=a||{},a.type||(a.type=\"nodebuffer\"),this.generateInternalStream(a).toNodejsStream(b)}};b.exports=s},{\"./compressedObject\":2,\"./defaults\":5,\"./generate\":9,\"./nodejs/NodejsStreamInputAdapter\":12,\"./nodejsUtils\":14,\"./stream/GenericWorker\":28,\"./stream/StreamHelper\":29,\"./utf8\":31,\"./utils\":32,\"./zipObject\":35}],16:[function(a,b,c){b.exports=a(\"stream\")},{stream:void 0}],17:[function(a,b,c){\"use strict\";function d(a){e.call(this,a);for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}var e=a(\"./DataReader\"),f=a(\"../utils\");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readAndCheckSignature=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.readData(4);return b===f[0]&&c===f[1]&&d===f[2]&&e===f[3]},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\"../utils\":32,\"./DataReader\":18}],18:[function(a,b,c){\"use strict\";function d(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}var e=a(\"../utils\");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error(\"End of data reached (data length = \"+this.length+\", asked index = \"+a+\"). Corrupted zip ?\")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo(\"string\",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readAndCheckSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},b.exports=d},{\"../utils\":32}],19:[function(a,b,c){\"use strict\";function d(a){e.call(this,a)}var e=a(\"./Uint8ArrayReader\"),f=a(\"../utils\");f.inherits(d,e),d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\"../utils\":32,\"./Uint8ArrayReader\":21}],20:[function(a,b,c){\"use strict\";function d(a){e.call(this,a)}var e=a(\"./DataReader\"),f=a(\"../utils\");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readAndCheckSignature=function(a){var b=this.readData(4);return a===b},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\"../utils\":32,\"./DataReader\":18}],21:[function(a,b,c){\"use strict\";function d(a){e.call(this,a)}var e=a(\"./ArrayReader\"),f=a(\"../utils\");f.inherits(d,e),d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{\"../utils\":32,\"./ArrayReader\":17}],22:[function(a,b,c){\"use strict\";var d=a(\"../utils\"),e=a(\"../support\"),f=a(\"./ArrayReader\"),g=a(\"./StringReader\"),h=a(\"./NodeBufferReader\"),i=a(\"./Uint8ArrayReader\");b.exports=function(a){var b=d.getTypeOf(a);return d.checkSupport(b),\"string\"!==b||e.uint8array?\"nodebuffer\"===b?new h(a):e.uint8array?new i(d.transformTo(\"uint8array\",a)):new f(d.transformTo(\"array\",a)):new g(a)}},{\"../support\":30,\"../utils\":32,\"./ArrayReader\":17,\"./NodeBufferReader\":19,\"./StringReader\":20,\"./Uint8ArrayReader\":21}],23:[function(a,b,c){\"use strict\";c.LOCAL_FILE_HEADER=\"PK\u0003\u0004\",c.CENTRAL_FILE_HEADER=\"PK\u0001\u0002\",c.CENTRAL_DIRECTORY_END=\"PK\u0005\u0006\",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR=\"PK\u0006\u0007\",c.ZIP64_CENTRAL_DIRECTORY_END=\"PK\u0006\u0006\",c.DATA_DESCRIPTOR=\"PK\u0007\\b\"},{}],24:[function(a,b,c){\"use strict\";function d(a){e.call(this,\"ConvertWorker to \"+a),this.destType=a}var e=a(\"./GenericWorker\"),f=a(\"../utils\");f.inherits(d,e),d.prototype.processChunk=function(a){this.push({data:f.transformTo(this.destType,a.data),meta:a.meta})},b.exports=d},{\"../utils\":32,\"./GenericWorker\":28}],25:[function(a,b,c){\"use strict\";function d(){e.call(this,\"Crc32Probe\"),this.withStreamInfo(\"crc32\",0)}var e=a(\"./GenericWorker\"),f=a(\"../crc32\"),g=a(\"../utils\");g.inherits(d,e),d.prototype.processChunk=function(a){this.streamInfo.crc32=f(a.data,this.streamInfo.crc32||0),this.push(a)},b.exports=d},{\"../crc32\":4,\"../utils\":32,\"./GenericWorker\":28}],26:[function(a,b,c){\"use strict\";function d(a){f.call(this,\"DataLengthProbe for \"+a),this.propName=a,this.withStreamInfo(a,0)}var e=a(\"../utils\"),f=a(\"./GenericWorker\");e.inherits(d,f),d.prototype.processChunk=function(a){if(a){var b=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=b+a.data.length}f.prototype.processChunk.call(this,a)},b.exports=d},{\"../utils\":32,\"./GenericWorker\":28}],27:[function(a,b,c){\"use strict\";function d(a){f.call(this,\"DataWorker\");var b=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type=\"\",this._tickScheduled=!1,a.then(function(a){b.dataIsReady=!0,b.data=a,b.max=a&&a.length||0,b.type=e.getTypeOf(a),b.isPaused||b._tickAndRepeat()},function(a){b.error(a)})}var e=a(\"../utils\"),f=a(\"./GenericWorker\"),g=16384;e.inherits(d,f),d.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,e.delay(this._tickAndRepeat,[],this)),!0)},d.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(e.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},d.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=g,b=null,c=Math.min(this.max,this.index+a);if(this.index>=this.max)return this.end();switch(this.type){case\"string\":b=this.data.substring(this.index,c);break;case\"uint8array\":b=this.data.subarray(this.index,c);break;case\"array\":case\"nodebuffer\":b=this.data.slice(this.index,c)}return this.index=c,this.push({data:b,meta:{percent:this.max?this.index/this.max*100:0}})},b.exports=d},{\"../utils\":32,\"./GenericWorker\":28}],28:[function(a,b,c){\"use strict\";function d(a){this.name=a||\"default\",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}d.prototype={push:function(a){this.emit(\"data\",a)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit(\"end\"),this.cleanUp(),this.isFinished=!0}catch(a){this.emit(\"error\",a)}return!0},error:function(a){return!this.isFinished&&(this.isPaused?this.generatedError=a:(this.isFinished=!0,this.emit(\"error\",a),this.previous&&this.previous.error(a),this.cleanUp()),!0)},on:function(a,b){return this._listeners[a].push(b),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(a,b){if(this._listeners[a])for(var c=0;c<this._listeners[a].length;c++)this._listeners[a][c].call(this,b)},pipe:function(a){return a.registerPrevious(this)},registerPrevious:function(a){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.streamInfo=a.streamInfo,this.mergeStreamInfo(),this.previous=a;var b=this;return a.on(\"data\",function(a){b.processChunk(a)}),a.on(\"end\",function(){b.end()}),a.on(\"error\",function(a){b.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var a=!1;return this.generatedError&&(this.error(this.generatedError),a=!0),this.previous&&this.previous.resume(),!a},flush:function(){},processChunk:function(a){this.push(a)},withStreamInfo:function(a,b){return this.extraStreamInfo[a]=b,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a)&&(this.streamInfo[a]=this.extraStreamInfo[a])},lock:function(){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var a=\"Worker \"+this.name;return this.previous?this.previous+\" -> \"+a:a}},b.exports=d},{}],29:[function(a,b,c){\"use strict\";function d(a,b,c,d){var f=null;switch(a){case\"blob\":return h.newBlob(c,d);case\"base64\":return f=e(b,c),k.encode(f);default:return f=e(b,c),h.transformTo(a,f)}}function e(a,b){var c,d=0,e=null,f=0;for(c=0;c<b.length;c++)f+=b[c].length;switch(a){case\"string\":return b.join(\"\");case\"array\":return Array.prototype.concat.apply([],b);case\"uint8array\":for(e=new Uint8Array(f),c=0;c<b.length;c++)e.set(b[c],d),d+=b[c].length;return e;case\"nodebuffer\":return Buffer.concat(b);default:throw new Error(\"concat : unsupported type '\"+a+\"'\")}}function f(a,b){return new m.Promise(function(c,e){var f=[],g=a._internalType,h=a._outputType,i=a._mimeType;a.on(\"data\",function(a,c){f.push(a),b&&b(c)}).on(\"error\",function(a){f=[],e(a)}).on(\"end\",function(){try{var a=d(h,g,f,i);c(a)}catch(b){e(b)}f=[]}).resume()})}function g(a,b,c){var d=b;switch(b){case\"blob\":d=\"arraybuffer\";break;case\"arraybuffer\":d=\"uint8array\";break;case\"base64\":d=\"string\"}try{this._internalType=d,this._outputType=b,this._mimeType=c,h.checkSupport(d),this._worker=a.pipe(new i(d)),a.lock()}catch(e){this._worker=new j(\"error\"),this._worker.error(e)}}var h=a(\"../utils\"),i=a(\"./ConvertWorker\"),j=a(\"./GenericWorker\"),k=a(\"../base64\"),l=a(\"../support\"),m=a(\"../external\"),n=null;if(l.nodestream)try{n=a(\"../nodejs/NodejsStreamOutputAdapter\")}catch(o){}g.prototype={accumulate:function(a){return f(this,a)},on:function(a,b){var c=this;return\"data\"===a?this._worker.on(a,function(a){b.call(c,a.data,a.meta)}):this._worker.on(a,function(){h.delay(b,arguments,c)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(a){if(h.checkSupport(\"nodestream\"),\"nodebuffer\"!==this._outputType)throw new Error(this._outputType+\" is not supported by this method\");return new n(this,{objectMode:\"nodebuffer\"!==this._outputType},a)}},b.exports=g},{\"../base64\":1,\"../external\":6,\"../nodejs/NodejsStreamOutputAdapter\":13,\"../support\":30,\"../utils\":32,\"./ConvertWorker\":24,\"./GenericWorker\":28}],30:[function(a,b,c){\"use strict\";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer=\"undefined\"!=typeof ArrayBuffer&&\"undefined\"!=typeof Uint8Array,c.nodebuffer=\"undefined\"!=typeof Buffer,c.uint8array=\"undefined\"!=typeof Uint8Array,\"undefined\"==typeof ArrayBuffer)c.blob=!1;else{var d=new ArrayBuffer(0);try{c.blob=0===new Blob([d],{type:\"application/zip\"}).size}catch(e){try{var f=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,g=new f;g.append(d),c.blob=0===g.getBlob(\"application/zip\").size}catch(e){c.blob=!1}}}try{c.nodestream=!!a(\"readable-stream\").Readable}catch(e){c.nodestream=!1}},{\"readable-stream\":16}],31:[function(a,b,c){\"use strict\";function d(){i.call(this,\"utf-8 decode\"),this.leftOver=null}function e(){i.call(this,\"utf-8 encode\")}for(var f=a(\"./utils\"),g=a(\"./support\"),h=a(\"./nodejsUtils\"),i=a(\"./stream/GenericWorker\"),j=new Array(256),k=0;k<256;k++)j[k]=k>=252?6:k>=248?5:k>=240?4:k>=224?3:k>=192?2:1;j[254]=j[254]=1;var l=function(a){var b,c,d,e,f,h=a.length,i=0;for(e=0;e<h;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=g.uint8array?new Uint8Array(i):new Array(i),f=0,e=0;f<i;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),c<128?b[f++]=c:c<2048?(b[f++]=192|c>>>6,b[f++]=128|63&c):c<65536?(b[f++]=224|c>>>12,b[f++]=128|c>>>6&63,b[f++]=128|63&c):(b[f++]=240|c>>>18,b[f++]=128|c>>>12&63,b[f++]=128|c>>>6&63,b[f++]=128|63&c);return b},m=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+j[a[c]]>b?c:b},n=function(a){var b,c,d,e,g=a.length,h=new Array(2*g);for(c=0,b=0;b<g;)if(d=a[b++],d<128)h[c++]=d;else if(e=j[d],e>4)h[c++]=65533,b+=e-1;else{for(d&=2===e?31:3===e?15:7;e>1&&b<g;)d=d<<6|63&a[b++],e--;e>1?h[c++]=65533:d<65536?h[c++]=d:(d-=65536,h[c++]=55296|d>>10&1023,h[c++]=56320|1023&d)}return h.length!==c&&(h.subarray?h=h.subarray(0,c):h.length=c),f.applyFromCharCode(h)};c.utf8encode=function(a){return g.nodebuffer?h.newBuffer(a,\"utf-8\"):l(a)},c.utf8decode=function(a){return g.nodebuffer?f.transformTo(\"nodebuffer\",a).toString(\"utf-8\"):(a=f.transformTo(g.uint8array?\"uint8array\":\"array\",a),n(a))},f.inherits(d,i),d.prototype.processChunk=function(a){var b=f.transformTo(g.uint8array?\"uint8array\":\"array\",a.data);if(this.leftOver&&this.leftOver.length){if(g.uint8array){var d=b;b=new Uint8Array(d.length+this.leftOver.length),b.set(this.leftOver,0),b.set(d,this.leftOver.length)}else b=this.leftOver.concat(b);this.leftOver=null}var e=m(b),h=b;e!==b.length&&(g.uint8array?(h=b.subarray(0,e),this.leftOver=b.subarray(e,b.length)):(h=b.slice(0,e),this.leftOver=b.slice(e,b.length))),this.push({data:c.utf8decode(h),meta:a.meta})},d.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:c.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},c.Utf8DecodeWorker=d,f.inherits(e,i),e.prototype.processChunk=function(a){this.push({data:c.utf8encode(a.data),meta:a.meta})},c.Utf8EncodeWorker=e},{\"./nodejsUtils\":14,\"./stream/GenericWorker\":28,\"./support\":30,\"./utils\":32}],32:[function(a,b,c){\"use strict\";function d(a){var b=null;return b=i.uint8array?new Uint8Array(a.length):new Array(a.length),f(a,b)}function e(a){return a}function f(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function g(a){var b=65536,d=c.getTypeOf(a),e=!0;if(\"uint8array\"===d?e=n.applyCanBeUsed.uint8array:\"nodebuffer\"===d&&(e=n.applyCanBeUsed.nodebuffer),e)for(;b>1;)try{return n.stringifyByChunk(a,d,b)}catch(f){b=Math.floor(b/2)}return n.stringifyByChar(a)}function h(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var i=a(\"./support\"),j=a(\"./base64\"),k=a(\"./nodejsUtils\"),l=a(\"core-js/library/fn/set-immediate\"),m=a(\"./external\");c.newBlob=function(a,b){c.checkSupport(\"blob\");try{return new Blob(a,{type:b})}catch(d){try{for(var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e,g=0;g<a.length;g++)f.append(a[g]);\nreturn f.getBlob(b)}catch(d){throw new Error(\"Bug : can't construct the Blob.\")}}};var n={stringifyByChunk:function(a,b,c){var d=[],e=0,f=a.length;if(f<=c)return String.fromCharCode.apply(null,a);for(;e<f;)\"array\"===b||\"nodebuffer\"===b?d.push(String.fromCharCode.apply(null,a.slice(e,Math.min(e+c,f)))):d.push(String.fromCharCode.apply(null,a.subarray(e,Math.min(e+c,f)))),e+=c;return d.join(\"\")},stringifyByChar:function(a){for(var b=\"\",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b},applyCanBeUsed:{uint8array:function(){try{return i.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(a){return!1}}(),nodebuffer:function(){try{return i.nodebuffer&&1===String.fromCharCode.apply(null,k.newBuffer(1)).length}catch(a){return!1}}()}};c.applyFromCharCode=g;var o={};o.string={string:e,array:function(a){return f(a,new Array(a.length))},arraybuffer:function(a){return o.string.uint8array(a).buffer},uint8array:function(a){return f(a,new Uint8Array(a.length))},nodebuffer:function(a){return f(a,k.newBuffer(a.length))}},o.array={string:g,array:e,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBuffer(a)}},o.arraybuffer={string:function(a){return g(new Uint8Array(a))},array:function(a){return h(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:e,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBuffer(new Uint8Array(a))}},o.uint8array={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){var b=new Uint8Array(a.length);return a.length&&b.set(a,0),b.buffer},uint8array:e,nodebuffer:function(a){return k.newBuffer(a)}},o.nodebuffer={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return o.nodebuffer.uint8array(a).buffer},uint8array:function(a){return h(a,new Uint8Array(a.length))},nodebuffer:e},c.transformTo=function(a,b){if(b||(b=\"\"),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=o[d][a](b);return e},c.getTypeOf=function(a){return\"string\"==typeof a?\"string\":\"[object Array]\"===Object.prototype.toString.call(a)?\"array\":i.nodebuffer&&k.isBuffer(a)?\"nodebuffer\":i.uint8array&&a instanceof Uint8Array?\"uint8array\":i.arraybuffer&&a instanceof ArrayBuffer?\"arraybuffer\":void 0},c.checkSupport=function(a){var b=i[a.toLowerCase()];if(!b)throw new Error(a+\" is not supported by this platform\")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d=\"\";for(c=0;c<(a||\"\").length;c++)b=a.charCodeAt(c),d+=\"\\\\x\"+(b<16?\"0\":\"\")+b.toString(16).toUpperCase();return d},c.delay=function(a,b,c){l(function(){a.apply(c||null,b||[])})},c.inherits=function(a,b){var c=function(){};c.prototype=b.prototype,a.prototype=new c},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&\"undefined\"==typeof c[b]&&(c[b]=arguments[a][b]);return c},c.prepareContent=function(a,b,e,f,g){var h=m.Promise.resolve(b).then(function(a){var b=i.blob&&(a instanceof Blob||[\"[object File]\",\"[object Blob]\"].indexOf(Object.prototype.toString.call(a))!==-1);return b&&\"undefined\"!=typeof FileReader?new m.Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(a.target.result)},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)}):a});return h.then(function(b){var h=c.getTypeOf(b);return h?(\"arraybuffer\"===h?b=c.transformTo(\"uint8array\",b):\"string\"===h&&(g?b=j.decode(b):e&&f!==!0&&(b=d(b))),b):m.Promise.reject(new Error(\"The data of '\"+a+\"' is in an unsupported format !\"))})}},{\"./base64\":1,\"./external\":6,\"./nodejsUtils\":14,\"./support\":30,\"core-js/library/fn/set-immediate\":36}],33:[function(a,b,c){\"use strict\";function d(a){this.files=[],this.loadOptions=a}var e=a(\"./reader/readerFor\"),f=a(\"./utils\"),g=a(\"./signature\"),h=a(\"./zipEntry\"),i=(a(\"./utf8\"),a(\"./support\"));d.prototype={checkSignature:function(a){if(!this.reader.readAndCheckSignature(a)){this.reader.index-=4;var b=this.reader.readString(4);throw new Error(\"Corrupted zip or bug : unexpected signature (\"+f.pretty(b)+\", expected \"+f.pretty(a)+\")\")}},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=i.uint8array?\"uint8array\":\"array\",c=f.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readData(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error(\"Multi-volumes zip are not supported\")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(g.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a=new h({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error(\"Corrupted zip or bug: expected \"+this.centralDirRecords+\" records in central dir, got \"+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,g.LOCAL_FILE_HEADER);throw b?new Error(\"Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html\"):new Error(\"Corrupted zip : can't find end of central directory\")}this.reader.setIndex(a);var c=a;if(this.checkSignature(g.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory locator\");if(this.reader.setIndex(a),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,g.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory\");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,g.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error(\"Corrupted zip: missing \"+Math.abs(e)+\" bytes.\")},prepareReader:function(a){this.reader=e(a)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{\"./reader/readerFor\":22,\"./signature\":23,\"./support\":30,\"./utf8\":31,\"./utils\":32,\"./zipEntry\":34}],34:[function(a,b,c){\"use strict\";function d(a,b){this.options=a,this.loadOptions=b}var e=a(\"./reader/readerFor\"),f=a(\"./utils\"),g=a(\"./compressedObject\"),h=a(\"./crc32\"),i=a(\"./utf8\"),j=a(\"./compressions\"),k=a(\"./support\"),l=0,m=3,n=function(a){for(var b in j)if(j.hasOwnProperty(b)&&j[b].magic===a)return j[b];return null};d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)\");if(b=n(this.compressionMethod),null===b)throw new Error(\"Corrupted zip : compression \"+f.pretty(this.compressionMethod)+\" unknown (inner file : \"+f.transformTo(\"string\",this.fileName)+\")\");this.decompressed=new g(this.compressedSize,this.uncompressedSize,this.crc32,b,a.readData(this.compressedSize))},readCentralPart:function(a){this.versionMadeBy=a.readInt(2),a.skip(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4);var b=a.readInt(2);if(this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error(\"Encrypted zip are not supported\");a.skip(b),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===l&&(this.dosPermissions=63&this.externalFileAttributes),a===m&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||\"/\"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});a.index<e;)b=a.readInt(2),c=a.readInt(2),d=a.readData(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=k.uint8array?\"uint8array\":\"array\";if(this.useUTF8())this.fileNameStr=i.utf8decode(this.fileName),this.fileCommentStr=i.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileName)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileComment)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null}},b.exports=d},{\"./compressedObject\":2,\"./compressions\":3,\"./crc32\":4,\"./reader/readerFor\":22,\"./support\":30,\"./utf8\":31,\"./utils\":32}],35:[function(a,b,c){\"use strict\";var d=a(\"./stream/StreamHelper\"),e=a(\"./stream/DataWorker\"),f=a(\"./utf8\"),g=a(\"./compressedObject\"),h=a(\"./stream/GenericWorker\"),i=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this._dataBinary=c.binary,this.options={compression:c.compression,compressionOptions:c.compressionOptions}};i.prototype={internalStream:function(a){var b=a.toLowerCase(),c=\"string\"===b||\"text\"===b;\"binarystring\"!==b&&\"text\"!==b||(b=\"string\");var e=this._decompressWorker(),g=!this._dataBinary;return g&&!c&&(e=e.pipe(new f.Utf8EncodeWorker)),!g&&c&&(e=e.pipe(new f.Utf8DecodeWorker)),new d(e,b,\"\")},async:function(a,b){return this.internalStream(a).accumulate(b)},nodeStream:function(a,b){return this.internalStream(a||\"nodebuffer\").toNodejsStream(b)},_compressWorker:function(a,b){if(this._data instanceof g&&this._data.compression.magic===a.magic)return this._data.getCompressedWorker();var c=this._decompressWorker();return this._dataBinary||(c=c.pipe(new f.Utf8EncodeWorker)),g.createWorkerFrom(c,a,b)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof h?this._data:new e(this._data)}};for(var j=[\"asText\",\"asBinary\",\"asNodeBuffer\",\"asUint8Array\",\"asArrayBuffer\"],k=function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},l=0;l<j.length;l++)i.prototype[j[l]]=k;b.exports=i},{\"./compressedObject\":2,\"./stream/DataWorker\":27,\"./stream/GenericWorker\":28,\"./stream/StreamHelper\":29,\"./utf8\":31}],36:[function(a,b,c){a(\"../modules/web.immediate\"),b.exports=a(\"../modules/_core\").setImmediate},{\"../modules/_core\":40,\"../modules/web.immediate\":56}],37:[function(a,b,c){b.exports=function(a){if(\"function\"!=typeof a)throw TypeError(a+\" is not a function!\");return a}},{}],38:[function(a,b,c){var d=a(\"./_is-object\");b.exports=function(a){if(!d(a))throw TypeError(a+\" is not an object!\");return a}},{\"./_is-object\":51}],39:[function(a,b,c){var d={}.toString;b.exports=function(a){return d.call(a).slice(8,-1)}},{}],40:[function(a,b,c){var d=b.exports={version:\"2.3.0\"};\"number\"==typeof __e&&(__e=d)},{}],41:[function(a,b,c){var d=a(\"./_a-function\");b.exports=function(a,b,c){if(d(a),void 0===b)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}}},{\"./_a-function\":37}],42:[function(a,b,c){b.exports=!a(\"./_fails\")(function(){return 7!=Object.defineProperty({},\"a\",{get:function(){return 7}}).a})},{\"./_fails\":45}],43:[function(a,b,c){var d=a(\"./_is-object\"),e=a(\"./_global\").document,f=d(e)&&d(e.createElement);b.exports=function(a){return f?e.createElement(a):{}}},{\"./_global\":46,\"./_is-object\":51}],44:[function(a,b,c){var d=a(\"./_global\"),e=a(\"./_core\"),f=a(\"./_ctx\"),g=a(\"./_hide\"),h=\"prototype\",i=function(a,b,c){var j,k,l,m=a&i.F,n=a&i.G,o=a&i.S,p=a&i.P,q=a&i.B,r=a&i.W,s=n?e:e[b]||(e[b]={}),t=s[h],u=n?d:o?d[b]:(d[b]||{})[h];n&&(c=b);for(j in c)k=!m&&u&&void 0!==u[j],k&&j in s||(l=k?u[j]:c[j],s[j]=n&&\"function\"!=typeof u[j]?c[j]:q&&k?f(l,d):r&&u[j]==l?function(a){var b=function(b,c,d){if(this instanceof a){switch(arguments.length){case 0:return new a;case 1:return new a(b);case 2:return new a(b,c)}return new a(b,c,d)}return a.apply(this,arguments)};return b[h]=a[h],b}(l):p&&\"function\"==typeof l?f(Function.call,l):l,p&&((s.virtual||(s.virtual={}))[j]=l,a&i.R&&t&&!t[j]&&g(t,j,l)))};i.F=1,i.G=2,i.S=4,i.P=8,i.B=16,i.W=32,i.U=64,i.R=128,b.exports=i},{\"./_core\":40,\"./_ctx\":41,\"./_global\":46,\"./_hide\":47}],45:[function(a,b,c){b.exports=function(a){try{return!!a()}catch(b){return!0}}},{}],46:[function(a,b,c){var d=b.exports=\"undefined\"!=typeof window&&window.Math==Math?window:\"undefined\"!=typeof self&&self.Math==Math?self:Function(\"return this\")();\"number\"==typeof __g&&(__g=d)},{}],47:[function(a,b,c){var d=a(\"./_object-dp\"),e=a(\"./_property-desc\");b.exports=a(\"./_descriptors\")?function(a,b,c){return d.f(a,b,e(1,c))}:function(a,b,c){return a[b]=c,a}},{\"./_descriptors\":42,\"./_object-dp\":52,\"./_property-desc\":53}],48:[function(a,b,c){b.exports=a(\"./_global\").document&&document.documentElement},{\"./_global\":46}],49:[function(a,b,c){b.exports=!a(\"./_descriptors\")&&!a(\"./_fails\")(function(){return 7!=Object.defineProperty(a(\"./_dom-create\")(\"div\"),\"a\",{get:function(){return 7}}).a})},{\"./_descriptors\":42,\"./_dom-create\":43,\"./_fails\":45}],50:[function(a,b,c){b.exports=function(a,b,c){var d=void 0===c;switch(b.length){case 0:return d?a():a.call(c);case 1:return d?a(b[0]):a.call(c,b[0]);case 2:return d?a(b[0],b[1]):a.call(c,b[0],b[1]);case 3:return d?a(b[0],b[1],b[2]):a.call(c,b[0],b[1],b[2]);case 4:return d?a(b[0],b[1],b[2],b[3]):a.call(c,b[0],b[1],b[2],b[3])}return a.apply(c,b)}},{}],51:[function(a,b,c){b.exports=function(a){return\"object\"==typeof a?null!==a:\"function\"==typeof a}},{}],52:[function(a,b,c){var d=a(\"./_an-object\"),e=a(\"./_ie8-dom-define\"),f=a(\"./_to-primitive\"),g=Object.defineProperty;c.f=a(\"./_descriptors\")?Object.defineProperty:function(a,b,c){if(d(a),b=f(b,!0),d(c),e)try{return g(a,b,c)}catch(h){}if(\"get\"in c||\"set\"in c)throw TypeError(\"Accessors not supported!\");return\"value\"in c&&(a[b]=c.value),a}},{\"./_an-object\":38,\"./_descriptors\":42,\"./_ie8-dom-define\":49,\"./_to-primitive\":55}],53:[function(a,b,c){b.exports=function(a,b){return{enumerable:!(1&a),configurable:!(2&a),writable:!(4&a),value:b}}},{}],54:[function(a,b,c){var d,e,f,g=a(\"./_ctx\"),h=a(\"./_invoke\"),i=a(\"./_html\"),j=a(\"./_dom-create\"),k=a(\"./_global\"),l=k.process,m=k.setImmediate,n=k.clearImmediate,o=k.MessageChannel,p=0,q={},r=\"onreadystatechange\",s=function(){var a=+this;if(q.hasOwnProperty(a)){var b=q[a];delete q[a],b()}},t=function(a){s.call(a.data)};m&&n||(m=function(a){for(var b=[],c=1;arguments.length>c;)b.push(arguments[c++]);return q[++p]=function(){h(\"function\"==typeof a?a:Function(a),b)},d(p),p},n=function(a){delete q[a]},\"process\"==a(\"./_cof\")(l)?d=function(a){l.nextTick(g(s,a,1))}:o?(e=new o,f=e.port2,e.port1.onmessage=t,d=g(f.postMessage,f,1)):k.addEventListener&&\"function\"==typeof postMessage&&!k.importScripts?(d=function(a){k.postMessage(a+\"\",\"*\")},k.addEventListener(\"message\",t,!1)):d=r in j(\"script\")?function(a){i.appendChild(j(\"script\"))[r]=function(){i.removeChild(this),s.call(a)}}:function(a){setTimeout(g(s,a,1),0)}),b.exports={set:m,clear:n}},{\"./_cof\":39,\"./_ctx\":41,\"./_dom-create\":43,\"./_global\":46,\"./_html\":48,\"./_invoke\":50}],55:[function(a,b,c){var d=a(\"./_is-object\");b.exports=function(a,b){if(!d(a))return a;var c,e;if(b&&\"function\"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;if(\"function\"==typeof(c=a.valueOf)&&!d(e=c.call(a)))return e;if(!b&&\"function\"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;throw TypeError(\"Can't convert object to primitive value\")}},{\"./_is-object\":51}],56:[function(a,b,c){var d=a(\"./_export\"),e=a(\"./_task\");d(d.G+d.B,{setImmediate:e.set,clearImmediate:e.clear})},{\"./_export\":44,\"./_task\":54}],57:[function(a,b,c){(function(a){\"use strict\";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode(\"\");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||\"undefined\"==typeof a.MessageChannel)e=\"document\"in a&&\"onreadystatechange\"in a.document.createElement(\"script\")?function(){var b=a.document.createElement(\"script\");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],58:[function(a,b,c){\"use strict\";function d(){}function e(a){if(\"function\"!=typeof a)throw new TypeError(\"resolver must be a function\");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,\"function\"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(e){return p.reject(a,e)}d===a?p.reject(a,new TypeError(\"Cannot resolve promise with itself\")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&\"object\"==typeof a&&\"function\"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);\"error\"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status=\"success\"}catch(d){c.status=\"error\",c.value=d}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if(\"[object Array]\"!==Object.prototype.toString.call(a))return this.reject(new TypeError(\"must be an array\"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if(\"[object Array]\"!==Object.prototype.toString.call(a))return this.reject(new TypeError(\"must be an array\"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a(\"immediate\"),p={},q=[\"REJECTED\"],r=[\"FULFILLED\"],s=[\"PENDING\"];b.exports=e,e.prototype[\"catch\"]=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if(\"function\"!=typeof a&&this.state===r||\"function\"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){var e=this.state===r?a:b;g(c,e,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if(\"error\"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{immediate:57}],59:[function(a,b,c){\"use strict\";var d=a(\"./lib/utils/common\").assign,e=a(\"./lib/deflate\"),f=a(\"./lib/inflate\"),g=a(\"./lib/zlib/constants\"),h={};d(h,e,f,g),b.exports=h},{\"./lib/deflate\":60,\"./lib/inflate\":61,\"./lib/utils/common\":62,\"./lib/zlib/constants\":65}],60:[function(a,b,c){\"use strict\";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:\"\"},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e=\"string\"==typeof b.dictionary?j.string2buf(b.dictionary):\"[object ArrayBuffer]\"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a(\"./zlib/deflate\"),i=a(\"./utils/common\"),j=a(\"./utils/strings\"),k=a(\"./zlib/messages\"),l=a(\"./zlib/zstream\"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,\"string\"==typeof a?e.input=j.string2buf(a):\"[object ArrayBuffer]\"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||(\"string\"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{\"./utils/common\":62,\"./utils/strings\":63,\"./zlib/deflate\":67,\"./zlib/messages\":72,\"./zlib/zstream\":74}],61:[function(a,b,c){\"use strict\";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:\"\"},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a(\"./zlib/inflate\"),h=a(\"./utils/common\"),i=a(\"./utils/strings\"),j=a(\"./zlib/constants\"),k=a(\"./zlib/messages\"),l=a(\"./zlib/zstream\"),m=a(\"./zlib/gzheader\"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,\"string\"==typeof a?m.input=i.binstring2buf(a):\"[object ArrayBuffer]\"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l=\"string\"==typeof p?i.string2buf(p):\"[object ArrayBuffer]\"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{\"./utils/common\":62,\"./utils/strings\":63,\"./zlib/constants\":65,\"./zlib/gzheader\":68,\"./zlib/inflate\":70,\"./zlib/messages\":72,\"./zlib/zstream\":74}],62:[function(a,b,c){\"use strict\";var d=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if(\"object\"!=typeof c)throw new TypeError(c+\"must be non-object\");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],63:[function(a,b,c){\"use strict\";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c=\"\",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a(\"./common\"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{\"./common\":62}],64:[function(a,b,c){\"use strict\";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=d},{}],65:[function(a,b,c){\"use strict\";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],66:[function(a,b,c){\"use strict\";function d(){\nfor(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],67:[function(a,b,c){\"use strict\";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a(\"../utils/common\"),F=a(\"./trees\"),G=a(\"./adler32\"),H=a(\"./crc32\"),I=a(\"./messages\"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"../utils/common\":62,\"./adler32\":64,\"./crc32\":66,\"./messages\":72,\"./trees\":73}],68:[function(a,b,c){\"use strict\";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}b.exports=d},{}],69:[function(a,b,c){\"use strict\";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg=\"invalid literal/length code\",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg=\"invalid distance code\",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg=\"invalid distance too far back\",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg=\"invalid distance too far back\",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],70:[function(a,b,c){\"use strict\";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg=\"\",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg=\"incorrect header check\",c.mode=ma;break}if((15&m)!==K){a.msg=\"unknown compression method\",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg=\"invalid window size\",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg=\"unknown compression method\",c.mode=ma;break}if(57344&c.flags){a.msg=\"unknown header flags set\",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg=\"header crc mismatch\",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg=\"invalid block type\",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg=\"invalid stored block lengths\",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg=\"too many length or distance symbols\",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg=\"invalid code lengths set\",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg=\"invalid bit length repeat\",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg=\"invalid bit length repeat\",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg=\"invalid code -- missing end-of-block\",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg=\"invalid literal/lengths set\",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg=\"invalid distances set\",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg=\"invalid literal/length code\",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg=\"invalid distance code\",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg=\"invalid distance too far back\",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg=\"invalid distance too far back\",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg=\"incorrect data check\",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg=\"incorrect length check\",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a(\"../utils/common\"),t=a(\"./adler32\"),u=a(\"./crc32\"),v=a(\"./inffast\"),w=a(\"./inftrees\"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"../utils/common\":62,\"./adler32\":64,\"./crc32\":66,\"./inffast\":69,\"./inftrees\":71}],71:[function(a,b,c){\"use strict\";var d=a(\"../utils/common\"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{\"../utils/common\":62}],72:[function(a,b,c){\"use strict\";b.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],73:[function(a,b,c){\"use strict\";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;\nfor(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a(\"../utils/common\"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{\"../utils/common\":62}],74:[function(a,b,c){\"use strict\";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});",
  "module.json": "{\n  \"input\": {\n    \"required\":[],\n    \"opts\":[]\n  },\n  \"output\":{\n    \"required\":[{\"par\":\"ApexList\"}],\n    \"opts\":[{\"par\":\"Login\",\"cmd\":[\"GenPage\"]}]\n  },\n  \"par\": {\n    \"required\":[\"ApexList\",\"Url\"],\n    \"opts\":[\"Port\",\"Login\"]\n  },\n  \"name\": \"Server\",\n  \"icon\": \"icon.png\",\n  \"doc\": \"Server.md\",\n  \"src\": \"xGraph:Web/Server\"\n}",
  "package.json": "{\n  \"name\" : \"Web\",\n  \"version\" : \"0.0.3\",\n  \"dependencies\" : {\n    \"socket.io\" : \"*\",\n\t\"jszip\":\"~3.1.3\",\n\t\"async\" : \"~0.9.0\"\n  }\n}",
  "schema.json": "{\n  \"Apex\": {\n\t\"$Setup\": \"Setup\",\n\t\"$Start\": \"Start\",\n\t\"Entity\": \"Http.js\"\n  }\n}\n",
  "scripts.json": "{\n  \"jszip.js\": \"jszip.min_3.1.3.js\",\n  \"async.js\": \"async.js\"\n}",
  "test.json": "{\n\t\"State\": {},\n    \"Cases\": [\n        {\n\t\t\t\"Command\": {\n\t\t\t\t\"Cmd\":\"GetModule\", \n\t\t\t\t\"Module\":\"xGraph.Web.Router\"\n\t\t\t},\n\t\t\t\"Response\": {\n\t\t\t\t\"Zip\":\"UEsDBAoAAAAAAAAomTfMlHRrnQoAAJ0KAAALAAAAbW9kdWxlLmpzb257IlJvdXRlci5qcyI6Ii8vIyBzb3VyY2VVUkw9Um91dGVyXG4oZnVuY3Rpb24gUm91dGVyKCkge1xuXG5cdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1kaXNwYXRjaFxuXHR2YXIgZGlzcGF0Y2ggPSB7XG5cdFx0U3RhcnQsXG5cdFx0U3Vic2NyaWJlLFxuXHRcdFwiKlwiOiBTZW5kXG5cdH07XG5cblx0cmV0dXJuIHtkaXNwYXRjaH07XG5cblx0ZnVuY3Rpb24gU3RhcnQoY29tLCBmdW4pIHtcblx0XHRjb25zb2xlLmxvZyhcIi0tUm91dGVyL1N0YXJ0XCIpO1xuXHRcdFxuXHRcdHRoaXMuc2VuZCh7Q21kOlwiU3Vic2NyaWJlXCIsIFBpZDp0aGlzLlBhci5QaWR9LCB0aGlzLlBhci5TZXJ2ZXIpO1xuXHRcdGlmIChmdW4pXG5cdFx0XHRmdW4obnVsbCwgY29tKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFN1YnNjcmliZShjb20sIGZ1bil7XG5cdFx0aWYgKCF0aGlzLlBhci5UYWJsZSlcblx0XHRcdHRoaXMuUGFyLlRhYmxlID0ge31cblx0XHRcblx0XHR0aGlzLlBhci5UYWJsZVtjb20uTmFtZV09IGNvbS5QaWQ7XG5cblx0XHRpZiAoZnVuKVxuXHRcdFx0ZnVuKG51bGwsIGNvbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBTZW5kKGNvbSwgZnVuKXtcblx0XHQvL2NvbnNvbGUubG9nKFwiUm91dGVyL1NlbmQgLSBcIiwgY29tLkNtZCk7XG5cdFx0dGhpcy5zZW5kKGNvbSwgdGhpcy5QYXIuVGFibGVbY29tLkRlc3RpbmF0aW9uXSwgZnVuKTtcblx0fVxuXG59KSgpOyIsIm1vZHVsZS5qc29uIjoie1xuICBcImlucHV0XCI6IHtcbiAgICBcInJlcXVpcmVkXCI6W1xuXHRcdHtcblx0XHRcdFwiQ21kXCI6XCJTdGFydFwiXG5cdFx0fVxuXHRdLFxuICAgIFwib3B0c1wiOltcblx0XHR7XG5cdFx0XHRcIkNtZFwiOlwiKlwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIkNtZFwiOlwiU3Vic2NyaWJlXCIsIFxuXHRcdFx0XCJBdHRyaWJ1dGVzXCI6e1xuXHRcdFx0XHRcInJlcXVpcmVkXCI6e1xuXHRcdFx0XHRcdFwiTmFtZVwiOlwibW9kdWxlTmFtZVwiLFxuXHRcdFx0XHRcdFwiUGlkXCI6XCJ4R3JhcGhQaWRcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRdXG4gIH0sXG4gIFwib3V0cHV0XCI6e1xuICAgIFwicmVxdWlyZWRcIjpbXG5cdFx0e1xuXHRcdFx0XCJwYXJcIjpcIlNlcnZlclwiLFxuXHRcdFx0XCJDb21tYW5kXCI6W1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0XCJDbWRcIjpcIlN1YnNjcmliZVwiLCBcblx0XHRcdFx0XHRcIkF0dHJpYnV0ZXNcIjp7XG5cdFx0XHRcdFx0XHRcInJlcXVpcmVkXCI6e1xuXHRcdFx0XHRcdFx0XHRcIlBpZFwiOlwieEdyYXBoUGlkXCJcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdF1cdFxuXHRcdH1cblx0XSxcbiAgICBcIm9wdHNcIjpbXVxuICB9LFxuICBcInBhclwiOiB7XG4gICAgXCJyZXF1aXJlZFwiOltcblx0XHR7XG5cdFx0XHRcImtleVwiOlwiU2VydmVyXCIsIFxuXHRcdFx0XCJmb3JtYXRcIjpcInhHcmFwaFBpZFwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImtleVwiOlwiVGFibGVcIiwgXG5cdFx0XHRcImZvcm1hdFwiOntcblx0XHRcdFx0XCJtb2R1bGVOYW1lXCI6XCJ4R3JhcGhQaWRcIlxuXHRcdFx0fVxuXHRcdH1cblx0XSxcbiAgICBcIm9wdHNcIjpbXVxuICB9LFxuICBcIm5hbWVcIjogXCJSb3V0ZXJcIixcbiAgXCJpY29uXCI6IG51bGwsXG4gIFwiZG9jXCI6IG51bGwsXG4gIFwiaW5mb1wiOntcImF1dGhvclwiOlwiVHJldnJHaW9uZXRcIn0sXG4gIFwic3JjXCI6IFwieEdyYXBoOldlYi9Sb3V0ZXJcIlxufVxuIiwic2NoZW1hLmpzb24iOiJ7XG5cdFwiQXBleFwiOiB7XG5cdFx0XCIkU3RhcnRcIjogXCJTdGFydFwiLFxuXHRcdFwiRW50aXR5XCI6IFwiUm91dGVyLmpzXCJcblx0fVxufVxuIiwidGVzdC5qc29uIjoie1xuXHRcIlN0YXRlXCI6IHtcblx0XHRcIlNlcnZlclwiOlwieEdyYXBoVGVzdGVyUGlkXCIsXG5cdFx0XCJUYWJsZVwiOntcblx0XHRcdFwiVGVzdFwiOlwieEdyYXBoVGVzdGVyUGlkXCJcblx0XHR9XHRcblx0fSxcbiAgICBcIkNhc2VzXCI6IFtcblx0XHR7XG5cdFx0XHRcIkNvbW1hbmRcIjoge1xuXHRcdFx0XHRcIkNtZFwiOlwiU3RhcnRcIlxuXHRcdFx0fSxcblx0XHRcdFwiU2VudE1lc3NhZ2VzXCI6W1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0XCJDbWRcIjpcIlN1YnNjcmliZVwiLCBcblx0XHRcdFx0XHRcIlBpZFwiOlwieEdyYXBoU2VsZlBpZFwiXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9LFxuICAgICAgICB7XG5cdFx0XHRcIkNvbW1hbmRcIjoge1xuXHRcdFx0XHRcIkNtZFwiOlwiU3Vic2NyaWJlXCIsIFxuXHRcdFx0XHRcIk5hbWVcIjpcIlRlc3REZXN0aW5hdGlvblwiLFxuXHRcdFx0XHRcIlBpZFwiOiBcInhHcmFwaFRlc3RlclBpZFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIkNvbW1hbmRcIjoge1xuXHRcdFx0XHRcIkNtZFwiOlwiVGVzdFwiLCBcblx0XHRcdFx0XCJEZXN0aW5hdGlvblwiOlwiVGVzdERlc3RpbmF0aW9uXCIsXG5cdFx0XHRcdFwiUGlkXCI6IFwieEdyYXBoVGVzdGVyUGlkXCJcblx0XHRcdH0sXG5cdFx0XHRcIlJlc3BvbnNlXCI6IHtcblx0XHRcdFx0XCJDbWRcIjogXCJUZXN0XCIsXG5cdFx0XHRcdFwiUGlkXCI6IFwiKlwiXHRcdFx0XHRcblx0XHRcdH1cblx0XHR9XG4gICAgXVxufSIsIk1vZE5hbWUiOiJ4R3JhcGguV2ViLlJvdXRlciIsIlN0YXJ0IjoiU3RhcnQifVBLAwQKAAAAAAAAKJk3+l1ncQ8AAAAPAAAADQAAAG1hbmlmZXN0Lmpzb25bIm1vZHVsZS5qc29uIl1QSwECFAAKAAAAAAAAKJk3zJR0a50KAACdCgAACwAAAAAAAAAAAAAAAAAAAAAAbW9kdWxlLmpzb25QSwECFAAKAAAAAAAAKJk3+l1ncQ8AAAAPAAAADQAAAAAAAAAAAAAAAADGCgAAbWFuaWZlc3QuanNvblBLBQYAAAAAAgACAHQAAAAACwAAAAA=\"\n\t\t\t}\n\t\t}\n    ]\n}",
  "ModName": "Jungle.Modules.Server",
  "Setup": "Setup",
  "Start": "Start"
}